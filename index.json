[{"uri":"http://docs.lucidarch.dev/introduction/","title":"Introduction","tags":[],"description":"","content":"Software architecture to build services that last with minimum technical dept; based on proven principles and practical guidelines.\n The Motive Developing large-scale applications has always been easy to think about but when it comes to implementation lots of questions arise especially when working in a collaborative team where every decision is peer-discussed and made over coffee or beer on a napkin. Some of these discussions go around fundamental subjects such as:\n Where should this good piece of art code reside (folder, file, class, etc.)? How should we apply these sets of design patterns to implement this feature? How can you describe the underlying architecture that is running‚Ä¶ EVERYTHING!?  Asking such questions is a brilliant start, knowing that every project or product we start working on starts from a mere idea - a spark - to help fulfil a human function. Nevertheless, deep in the back of our heads we know that at some point in the future it will grow and we don\u0026rsquo;t want it to grow on us, we\u0026rsquo;d rather have it grow with us. Especially in an agile culture we want the pieces of our applications to be easily interchangeable with the least friction possible and keeping technical debt to a minimum.\nWhat is an architecture anyway? But a pattern of connected structures cooperating according to a set of guidelines and principles to serve their purpose.\nFrom that sentence, Lucid will be the practical set of guidelines and principles to build backend services that last.\nThe following questions will also help ensure that you should incorporate Lucid in your current or upcoming project:\n Have you ever been onboarded to a code that is completely custom to the point that it Have you seen a Laravel project, even though it has been provided with Laravel\u0026rsquo;s impeccable simplicity, somehow managed to be ruined by endless whirlpools of huge controllers and deeply dependant and connected classes?  These situations and many more are best described in the following picture, which analogy is our application in a few months time.\n  Technical debt due to intertwined object relationships in a legacy application.  If you would like the image above to become something as below\u0026hellip;\n  Clear and precise composition of objects.   You\u0026rsquo;re in the right place! Lucid ‚Ä¢ Laravel Within controllers and commands, our application is prone to disorder due to the high degree of autonomy in MVC. Lucid fills that gap to complete the chain of Laravel\u0026rsquo;s MVC framework.\nThe relationship between Laravel and Lucid is that they complete each other. Lucid will be the bond between the application\u0026rsquo;s entry points and the components that do the actual work (classes, interfaces, design patterns etc.) securing code from meandering in drastic directions.\nIn fact, the very first announcement of Lucid to the public was in Laracon EU 2016 two years after its in-house use. See video below if you would like to watch the announcement:\n  Abed Halawi - The lucid architecture for building scalable applications - Laracon EU 2016  The Architecture At a glance\u0026hellip;\nFramework Provides the ‚Äúkernel‚Äù, request/response lifecycle, dependency injection and the core functionalities for the Foundation to build on. Knows nothing about the application logic. All this with the power of Laravel.\nFoundation Provides support to the concrete components of the architecture (services, domains and data) by extending the framework with fundamental (abstract) classes; due to that, and the fact that the concrete components will only deal with the foundation, any change at the framework level will be transparent and have the least effect possible on the application overall and as a result the Lucid architecture grants a reduced amount of technical debt in the case of a drastic update/upgrade or even migration to another framework.\nExamples of what the Foundation might include:\n FoundationController to be extended by the controllers in services Entity class that extends a base class such as an Eloquent model Decorators for validation, authentication and other fundamental yet shared functionality  Services They implement the features but do not implement the logic of the feature themselves, their responsibility is to compose Jobs and Operations from Domains. Think of a Job as a step if the feature was a user story; and an Operation is a group of steps that are often executed together to accomplish a single purpose.\nExample: a project consisting of an API and an Admin where you would implement each in its own scope for separation of concerns yet use common code between them using Domains and Data.\n Terminology\nThe terminology of a service is used in the form of ‚ÄúOur application provides data through an API service, it also has an Admin service with a user interface to perform advanced data manipulation procedures.\nHierarchy\nThe hierarchy of services and their components is as described in the pyramid below, given the example of an HTTP request:\nDomains They implement the business logic and expose them through jobs, they are isolated and MUST NOT inter-communicate [no domain calls another]. Their objective is to categories the jobs that accomplish unit-level tasks in our application within a definite scope.\nExample: in a task management app there‚Äôs the User domain and Task domain each having its own validators, generators, builders, factories, utility classes etc. and they utilise the data layer to perform data-specific procedures in addition to Jobs that are (favourably) the only way to communicate with domains. Potential Jobs in a task management app in the Task domain could be: SaveTaskJob, MarkTaskCompletedJob, AssignTaskToUserJob , where each of these is a class of its own. More on Jobs in Definitions.\n We suffix Job classnames with Job for readability and easier navigation, also extending the PSR-2 coding standard of suffixing interfaces with Interface and traits with Trait.\n Data Owns the data (duh!), which means models (entities), repositories, value objects, enums\u0026hellip; you name it. You may be asking why separate the data layer from the domains layer? aren‚Äôt they related? The answer is of course they are! Yet domains remain to be isolate, self-satisfied and no cross-domain relationships exist while data is organically related; if we included them in domains we would‚Äôve ended up working with cross-domain dependencies which defies the idea of domains being self-contained.\nAnother reason for having a separate data layer is the trend of the 21st centry: üí´data science‚ú® which makes this layer the place for your¬†statistics and analytics algorithms, a central layer for the elements of data.\nPrinciple: Domains, Jobs and Operations are isolated classes with single responsibilities, they perform one thing and one thing only; no inter-domain, inter-job or inter-operation dependencies should exist whatsoever.\n Congratulations for making it thus far! It may feel a little rough though, and that\u0026rsquo;s why there is more to these concepts for you to dig into.\n"},{"uri":"http://docs.lucidarch.dev/philosophy/","title":"Philosophy","tags":[],"description":"","content":"Throughout our careers as engineers we encounter numerous similar tasks disguised in different forms, maybe having slight differences. Every time we encounter the same task, we think it through based on our previous accomplishment of the task and figure out a better way to do it according to our gained experience. In the field of science, this is the natural progression of the learning experience - trial and error. Nevertheless, many have tried before us and have passed best practices that we [as a community] adopted as principles and guidelines to become an organic extension of our workflow, intrinsically applying them with little thinking effort.\nLucid is not any different, it is an amalgamation of experiences in building scalable products to serve various industries by interchangeable teams. Based on the many mistakes we\u0026rsquo;ve made and the suffering we\u0026rsquo;ve had when we go back to a \u0026ldquo;legacy\u0026rdquo; project, or during the onboarding process of someone new to the team, where the training process cannot keep up with the variety of opinions that\u0026rsquo;s been implemented in different projects, regardless of whether they\u0026rsquo;re right or wrong, they are many and have no single basis, a foundation, or an single architecture.\nWe wanted something simple [KISS] yet effective at scale. Enjoyable to work with by all levels of engineers alike. And elevates the level of understanding abstraction throughout its steep learning process. Simply put:\n Lucid is a set of principles that depend on our discipline to preserve    Name \u0026ldquo;Expressed clearly; easy to understand\u0026rdquo; marks the ultimate objective that the architecture intends to achieve in code.\n  Emblem    Foundation The more you look at it, the different shapes you will see. Some of these shapes may seem like a building or a block and they go in different directions. However, they are all starting from the same center - The Foundation.\nResilience From it emerges lines that have equal height, though go in different directions but have similar characteristics - representing the malleability of Lucid. Though, without guidelines and principles the outcome will not be desirable. Hence the straight lines that go in one and only one direction, representing the responsibility of each component in our code regardless of its destination.\nDirection The compass was an inspiration to the logo - without it we will surely get lost. Not knowing where we are, in which direction to go and how to go there is even worse. However, if we\u0026rsquo;ve been down the same road before it will be easier to know what should happen next.\nLike a compass, Lucid provides the guidance and acts as a reliable companion to your code navigation journey.\nAlso, a compass has no final destination and is only there to lead us wherever we wish to go, similar to any project that is ever evolving but the compass will never change direction.\nClarity From darkness to light. The dark end of the logo represents the chaos that our projects end up having after a long period of work and re-work, the variety of features they contain along with their changes. Going through the foundation (the center) - in this case Lucid - our projects go out of the other side in light - clear, understandable and easy to work with.\n"},{"uri":"http://docs.lucidarch.dev/routing/","title":"Routing","tags":[],"description":"","content":"Out of the SOLID principles - of which we are disciples - we\u0026rsquo;ve taken Single Responsibility seriously and created components that define the responsibilities beyond an MVC\u0026rsquo;s controller or any other modern application\u0026rsquo;s entry point, be it a route/request or a command. Which is where it is loose and chaos builds its nest. Within a controller we can do anything, and whichever architecture we follow (or don\u0026rsquo;t) we can still create a mess due to not having a specific guideline that helps contain the chaos.\nHere we define the responsibility of each component starting from MVC and moving through Lucid to keep codebase organised, defined and understandable at a glance, supporting whichever design patterns we decide to adopt:\n  Router A router is like a door that one can open to enter a room. A door does not concern itself with what the room contains or what its purpose is. It is simply a door. However, sometimes we have some security pass for the door to open, so a router can be configured to include components that perform security checks and other forms of entrance preparation.\n  Responsibility: Expose a feature from the application over HTTP, routing the request to the corresponding controller method.\nKernel Use Lucid Units (Feature, Job, Operation) to implement your middleware functionality. Code that you may use anywhere else in your application can be easily shared in\n  This space is best to:\n Define the URL you want your application to allow entries through. Define the controller method that should handle the request and serve the Feature. Perform pre-flight / middleware work such as request authorisation, preparation [does not include input validation].  "},{"uri":"http://docs.lucidarch.dev/controllers/","title":"Controllers","tags":[],"description":"","content":"In an effort to minimise the work of controllers, for they are not here to do work for the application but to point the request in the right direction. In Lucid terms, to serve the intended feature to the user.\nEventually we will end up having one line within each controller method, achieving the thinnest form possible.\n  Responsibility: Serve the designated feature.\nWhat you should do in a controller:\n Serve a feature. Prepare input as required by the feature that\u0026rsquo;s being served [does not include input validation]   Generate Controller Class Use lucid CLI to generate a controller that extends Lucid\u0026rsquo;s Controller class by default, which allows us to serve features features using the built-in serve method.\nMicro Signature\nlucid make:controller \u0026lt;controller\u0026gt; Example\nlucid make:controller Article Generated class will be at app/Http/Controllers/ArticleController.php\nMonolith Signature\nlucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:controller Article MyService Generated class will be at src/Services/MyService/Http/Controllers/ArticleController.php\n  For more details on this command see the help manual with lucid make:controller --help or visit make:controller\n Serve Features   To serve a Feature from controllers simply call the serve method provided by Lucid\u0026rsquo;s parent controller.\nuse Lucid\\Foundation\\Http\\Controller; use App\\Features\\UpdateArticleFeature; class ArticleController extends Controller { public function articles() { return $this-\u0026gt;serve(ListArticlesFeature::class); } } Request Input The served feature will be able to inject Request class to access request properties. This keeps our controllers clean and allows us to concentrate on what matters to the feature only.\nclass ListArticlesFeature { public function handle(Request $request) { $input = $request-\u0026gt;input(); // or  $title = $request-\u0026gt;input(\u0026#39;title\u0026#39;); } } Feature Parameters To pass parameters to a feature, we use the same syntax as dispatching a Laravel job:\nuse Lucid\\Foundation\\Http\\Controller; use App\\Features\\UpdateArticleFeature; class ArticleController extends Controller { public function update($id) { return $this-\u0026gt;serve(UpdateArticleFeature::class, [\u0026#39;id\u0026#39; =\u0026gt; $id]); } } The id key will be mapped to $id constructor param UpdateArticleFeature::constructor($id).\n Parameter and constructor variable names must match. And they\u0026rsquo;re case sensitive!\n Using associative arrays as properties has the advantage of disregarding the order in which the parameters are defined in the class we\u0026rsquo;re calling. However, they should be only what the feature needs to operate.\nclass UpdateArticleFeature extends Feature { private $id; public function __construct(string $id) { $this-\u0026gt;id = $id; } public function handle(Request $request) { $this-\u0026gt;run(UpdateArticleDataJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;id, \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;content\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;content\u0026#39;); ]); } } For more on writing features see the Feature section.\n"},{"uri":"http://docs.lucidarch.dev/features/","title":"Features","tags":[],"description":"","content":"Represents a human-readable project feature in a class, named the way you would describe it to your colleagues and clients. It contains the logic of implementing the feature with minimum friction and level of detail to remain concise and straight to the point.\nIt runs Lucid Units: Jobs and Operations to perform its tasks. They are thought of as the steps in the process of serving its purpose. A Feature can be served from anywhere, most commonly Controllers and Commands. Can also be queued to run asynchronously using Laravel\u0026rsquo;s powerful Queueing capabilities.\n Technically, it is a class that encapsulates all the functionalities required for a single request/response lifecycle (or command), in which the handle method represents the task list when you want to implement it in your application.\nExample: This is how a Feature class typically looks like. (simplified)\nclass UpdateProductFeature extends Feature { private string $id; public function __construct(string $id) { $this-\u0026gt;id = $id; } public function handle(Request $request) { $this-\u0026gt;run(ValidateProductInputJob::class, $request-\u0026gt;input()); $product = $this-\u0026gt;run(SaveProductJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;id, \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), ]); return $this-\u0026gt;run(new RespondWithJsonJob($product)); } }   Running Lucid Units asynchronously is as simple as having them implement the Queueable interface, applies to all of units such as Jobs and Operations and Features.\n   Responsibility: Perform the steps required to accomplish the feature by running Jobs and Operations.\nclass UserController extends Controller { public function login() { return $this-\u0026gt;serve(LoginUserFeature::class); } } Generate Feature Class Use lucid CLI to generate a Feature class that extends Lucid\u0026rsquo;s Feature base class by default, which allows us to run jobs and operations using the built-in run method.\nMicro Signature\nlucid make:feature \u0026lt;feature\u0026gt; Example\nlucid make:feature ListProducts Generated class will be at app/Features/ListProductsFeatures.php\nand its test at tests/Features/ListProductsFeaturesTest.php\nMonolith Signature\nlucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:feature ListProducts Commerce Generated class will be at src/Services/Commerce/Features/ListProductsFeatures.php\nand its test at src/Services/Commerce/Tests/Features/ListProductsFeaturesTest.php\n The generated Feature class will automatically be suffixed with Feature, so the class above will be ListProductsFeature.\n For more details on this command see the help manual with lucid make:feature --help\n Inside Features There are two essential highlights in a feature:\n Signature (a.k.a constructor parameters): Looking at the signature of the Feature should give the idea of what is required for it to be served. handle method: Looking at the class\u0026rsquo;s handle method should provide an overview of the steps required to serve the feature to the user (or any consuming party) without having to know too much details about the inner workings of each step. More on this at below.    class CreateArticleFeature extends Feature { public function handle(Request $request) { $this-\u0026gt;run(new ValidateArticleInputJob($request-\u0026gt;input())); $this-\u0026gt;run(UploadFilesToCDNJob::class, [\u0026#39;files\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;files\u0026#39;)]); $slug = $this-\u0026gt;run(new GenerateSlugJob($request-\u0026gt;input(\u0026#39;title\u0026#39;))); $article = $this-\u0026gt;run(SaveArticleJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;body\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;body\u0026#39;), \u0026#39;slug\u0026#39; =\u0026gt; $slug, ] ); return $this-\u0026gt;run(new RespondWithJsonJob($article)); } } As shown in the example above, there are several ways to run Jobs in features that are explained in details in the definition of Jobs.\n It is recommended to always specify the required parameters in each unit\u0026rsquo;s constructor rather than hiding them within the unit. i.e. pass each input parameter separately rather than the entire $request-\u0026gt;input(), or relying on the unit to inject Request class. This way we keep it clear to know what is required for a job or operation to do its work.\n The handle method Lucid units (Feature, Job, Operation) are simply classes extending Laravel\u0026rsquo;s base Job class with extra functionality that ties them together. Hence, the use of handle method as the invocation point for each of these units.\npublic function handle(Request $request) This method is called automatically when running $this-\u0026gt;serve(Feature::class) and it goes through Laravel\u0026rsquo;s IoC to resolve dependencies. In this example we included the Request class to be resolved so that we can access it and pass input to Jobs. Request could\u0026rsquo;ve been any other class in the application that can be resolved using IoC.\npublic function handle(MyCustomClass $mcc) This is the recommended way of using classes to maintain testability by interchanging class instances with their mocks.\n handle is the same for all Lucid units: Feature, Job and Operation and it behaves the same everywhere.\n Serving Features You may serve features from anywhere in your application! Here are some exapmles of doing so.\nHTTP If your controller is generated through the lucid command, all you need to do is call serve within the controller method, otherwise, have your controller (or parent controller) extend Lucid\u0026rsquo;s controller Lucid\\Foundation\\Http\\Controller.\nuse Lucid\\Foundation\\Http\\Controller; use App\\Features\\UpdateProductsFeature; class ProductController extends Controller { public function products() { return $this-\u0026gt;serve(ListProductsFeature::class); } } Command To run a feature from the command we just need to equip our Command class with Lucid\u0026rsquo;s methods by simply using ServesFeaturesTrait\nuse Illuminate\\Console\\Command; use App\\Features\\CleanStaleCartsFeature; use Lucid\\Foundation\\ServesFeaturesTrait; class CleanStaleCarts extends Command { use ServesFeaturesTrait; protected $signature = \u0026#39;clean:carts --stale\u0026#39;; protected $description = \u0026#34;Cleans inactive customer carts.\u0026#34;; public function handle() { return $this-\u0026gt;serve(CleanStaleCartsFeature::class); } } Other Just like we did for Commands we may do the same in any class we want, by simply using ServesFeaturesTrait the serve method will be available.\nuse App\\Features\\DoSomethingFeature; use Lucid\\Foundation\\ServesFeaturesTrait; class ToServeFeaturesHere { use ServesFeaturesTrait; public function give() { return $this-\u0026gt;serve(GiveHighFiveFeature::class); } } Testing When generating a feature with lucid make:feature a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nMicro lucid make:feature ListProductsFeature\nWould generate two files:\n app/Features/ListProductsFeature tests/Features/ListProductsFeatureTest  Monolith lucid make:feature ListProductsFeature api\nWould generate two files:\n src/Services/Api/Features/ListProductsFeature src/Services/Api/Tests/Features/ListProductsFeatureTest  Since Monolith is about scope and distribution of responsibility, and features are a scope of a service, tests are distributed and scoped accordingly in the corresponding service.\n Feature tests are equivalent to functional tests in a typical application. It is about testing how the feature would behave with a certain input combination from a user\u0026rsquo;s perspective.\nIf the feature is served over an HTTP request, the test would be about actually requesting the URL and passing parameters to receive the expected output, in addition to further assertions in the case of storage or other application aspects that require further assertion.\nThe example below is incomplete (e.g. $fake must be defined) just to illustrate the concept.\n class UpdateProductDetailsFeatureTest extends TestCase { public function test_successful_product_details_update() { $product = [ \u0026#39;id\u0026#39; =\u0026gt; $fake-\u0026gt;uuid, \u0026#39;title\u0026#39; =\u0026gt; $fake-\u0026gt;sentence, \u0026#39;description\u0026#39; =\u0026gt; $fake-\u0026gt;text, \u0026#39;price\u0026#39; =\u0026gt; $faker-\u0026gt;randomNumber(2), ]; // request  $response = $this-\u0026gt;put(\u0026#34;/products/{$product[\u0026#39;id\u0026#39;]}\u0026#34;, $product); $response-\u0026gt;assertStatus(200) -\u0026gt;assertJson([ \u0026#39;updated\u0026#39; =\u0026gt; true ]); // storage  $stored = Product::find($production[\u0026#39;id\u0026#39;]); $this-\u0026gt;assertEquals($product, $stored-\u0026gt;toArray()); } public function test_failing_product_details_update() { $product = [ \u0026#39;id\u0026#39; =\u0026gt; $fake-\u0026gt;uuid, \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, // cannot be empty  \u0026#39;description\u0026#39; =\u0026gt; $fake-\u0026gt;text, \u0026#39;price\u0026#39; =\u0026gt; $faker-\u0026gt;randomNumber(2), ]; $response = $this-\u0026gt;put(\u0026#34;/products/{$product[\u0026#39;id\u0026#39;]}\u0026#34;, $product); $response-\u0026gt;assertStatus(200) -\u0026gt;assertJson([ \u0026#39;updated\u0026#39; =\u0026gt; false, \u0026#39;error\u0026#39; =\u0026gt; [ \u0026#39;messages\u0026#39; =\u0026gt; [\u0026#39;title field is required.\u0026#39;], ], ]); // storage - ensure original title is still in place  $stored = Product::find($production[\u0026#39;id\u0026#39;]); $this-\u0026gt;assertEquals(\u0026#39;previous title\u0026#39;, $stored-\u0026gt;title); } } As far as functional testing goes, it is best to portray the usage of the feature from a broad perspective rather than digging into every detail of the steps of the function. Feature testing is usually considered to be the integration test between the units that make up the feature.\nMocking It is recommended with feature tests to only mock what\u0026rsquo;s external to your application to preserve the quality guarantee . Mocks are usually for 3rd-party APIs and other services that we integrate with, but not for internals such as storage.\nFor this example we will assume that this feature runs from a command line rather than over HTTP.\nThis example contains missing variables and is for illustrative purposes only.\n app/Features/UpdateFacebookPosts.php\nclass UpdateFacebookPosts extends Feature { public function handle() { $posts = $this-\u0026gt;run(FetchFacebookPostsJob::class); $this-\u0026gt;run(StoreFacebookPostsJob::class, [ \u0026#39;posts\u0026#39; =\u0026gt; $posts, ]); } } app/Domains/Facebook/Jobs/FetchFacebookPostsJob.php\nclass FetchFacebookPostsJob extends Job { public function handle(FacebookClient $fb) { return $fb-\u0026gt;posts(); } } tests/Features/UpdateFacebookPostsTest.php\nclass UpdateFacebookPostsTest extends TestCase { public function test_successfully_fetching_facebook_posts() { $mFB = Mockery::mock(FacebookClient::class); $mFB-\u0026gt;shouldReceive(\u0026#39;get\u0026#39;)-\u0026gt;with($args)-\u0026gt;andReturn($payload); $this-\u0026gt;app-\u0026gt;instance(FacebookClient::class, $mFB); $f = new UpdateFacebookPosts(); $result = $f-\u0026gt;handle(); // 0 in CLI means success!  $this-\u0026gt;assertEquals(0, $result); } } As shown in FetchFacebookPostsJob the client has been injected, so we had to replace the instance in IoC to load our mocked instance instead of the real one.\n FAQ What not to do in a feature?  Complex conditional logic: The feature passes output from Jobs and Operations but it barely knows anything about what goes on inside them. It only knows the sequence in which they should run and [maybe] some basic logic that is better be avoided and delegated to jobs and operations of possible. Process output from units: Parsing and transformation of content is best done in Job or an Operation. The output returned by a these units should always go as-is to the next unit. The feature doesn\u0026rsquo;t know much about the internals of steps or how they are actually performed. It is only aware of the sequence of the steps and the requirements of the different units through their signatures. This guarantees consistency and predictability when reading the feature\u0026rsquo;s code in the handle method and allows anyone new to the code to skim through quickly and have an idea about the required steps. Call another Feature: In order to avoid the Pyramid of Doom and reduce the cognitive load required to navigate the codebase and understand the code, Features should not call each other. Though the same feature may be called numerous times as long as it does not add up to the Feature\u0026rsquo;s complexity.   Should a Feature pass the entire set of input to other units? More elaborately: instead of specifying parameters in constructors, jobs and operations would accept an associative array of input and operate on that instead of a concise set of parameters.\nAnother option from\nFor several reasons:\n Clarity: Isolation: Reusability:   [Monolith] What to do about duplicate functionality between services? TL;DR It is recommended to have similar features across services than share features between them. Even if it meant repeating the same sequence of units.\n Since Monolith is all about separation of concerns per service, when dealing with multiple sides of the same application (e.g. Api, CMS, Web UI, etc.) we\u0026rsquo;d need to deal with their features differently; maybe not at the beginning but eventually we\u0026rsquo;ll find ourselves dealing with too many options and cramming a lot of confusing parameters in the same feature because we decided to share it with multiple services. To avoid all this, it is best to create a feature per service even if it means to repeat the same sequence of units. Below is a brief example to illustrate it.\nShared Feature\nSupposing that we decided to move the feature class from src/Services/{service}/Features to a place all services may access like app/Features/UpdateProductDetailsFeature.php and we\u0026rsquo;d like our Api and Web services to use it. This feature should serve the response in JSON when in the Api service and return a view when in Web:\nclass UpdateProductDetailsFeature { private $isApi; public function __construct(bool $isApi) { $this-\u0026gt;isApi = $isApi; } public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), ]); if ($this-\u0026gt;isApi) { return $this-\u0026gt;run(new RespondWithJsonJob($product)); } return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;product\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), ]); } }  This is yet a simple example but if we were to add more conditions to customize the experience further, we\u0026rsquo;d be throwing plenty of $this-\u0026gt;isApi everywhere in our feature. For example: the user reference from the API is a token, while the one from the Web is an ID retrieved from the session. Here\u0026rsquo;s how it would look like:\npublic function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); if ($this-\u0026gt;isApi) { $user = $this-\u0026gt;run(GetUserByApiTokenJob::class, [ \u0026#39;token\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;token\u0026#39;), ]); } else { $user = $this-\u0026gt;run(GetUserFromSessionJob::class); } $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;user\u0026#39; =\u0026gt; $user, ]); if ($this-\u0026gt;isApi) { return $this-\u0026gt;run(new RespondWithJsonJob($product)); } return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;product\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), ]); }  Ugly, isn\u0026rsquo;t it? See the other example for a cleaner approach below.\nFeature per Service\nApi::UpdateProductDetailsFeature\nlocated at src/Services/Api/Features/UpdateProductDetailsFeature.php\nclass UpdateProductDetailsFeature { public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); $user = $this-\u0026gt;run(GetUserFromSessionJob::class); $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;user\u0026#39; =\u0026gt; $user, ]); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;web.product.update\u0026#39;, ]); } }  Web::UpdateProductDetailsFeature\nlocated at src/Services/Web/Features/UpdateProductDetailsFeature.php\nclass UpdateProductDetailsFeature { public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); $user = $this-\u0026gt;run(GetUserByApiTokenJob::class, [ \u0026#39;token\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;token\u0026#39;), ]); $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;user\u0026#39; =\u0026gt; $user, ]); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;product\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), ]); } }   "},{"uri":"http://docs.lucidarch.dev/jobs/","title":"Jobs","tags":[],"description":"","content":"Jobs do the actual work. Being the smallest unit in Lucid, a Job should do one thing, and one thing only. That is: perform a single task. They are the snippets of code we wish we had sometimes, and are pluggable to use anywhere in our application.\nOur objective with Jobs is to limit the scope of a single functionality so that we know where to look when finding it, and when we\u0026rsquo;re within its context we don\u0026rsquo;t tangle responsibility with other jobs to achieve the ultimate form of single responsibility principle.\nUsually called by a Feature or an Operation, but can be called anywhere by any other class as well; hence, being the most shareable pieces of code.\n Jobs in Domains Domains are where jobs live. It is how they\u0026rsquo;re organized in the folder structure, and represent the execution point of a single functionality within the corresponding domain. In other words, the only way to access a domain should be through a Job.\nHere\u0026rsquo;s an example of two domains (User \u0026amp; Product) exposing functionality through jobs.\n User [domain]  LoginUserJob LogoutUserJob UpdateUserProfileJob   Product [domain]  FindProductByIDJob SearchForProductJob SaveProductDetailsJob ValidateProductDetailsJob    Each of these is a class. Similar to other Lucid units it uses __constructor to define required parameters and is executed through the handle method when calling run.\nExample\nIn a Feature or Operation we can use $this-\u0026gt;run(ValidateProductDetailsJob::class) to run the job\u0026rsquo;s handle method.\n{app|src}/Domains/Product/ValidateProductDetailsJob\nuse Lucid\\Foundation\\Job; use App\\Domains\\Product\\ProductValidator; class ValidateProductDetailsJob extends Job { private array $input; public function __constructor(array $input) { $this-\u0026gt;input = $input; } /** * @param ProductValidator $validator * * @throws InvalidInputException */ public function handle(ProductValidator $validator) { $validator-\u0026gt;validate($this-\u0026gt;input); } } And in our feature: .../Features/AddProductFeature.php\nuse App\\Domains\\Http\\Jobs\\RespondWithJsonJob; use App\\Domains\\Product\\Jobs\\SaveProductDetailsJob; use App\\Domains\\Product\\Jobs\\ValidateProductDetailsJob; class AddProductFeature extends Feature { public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDetailsJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input(), ]); $product = $this-\u0026gt;run(SaveProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), ]); return $this-\u0026gt;run(new RespondWithJsonJob($product)); } } Characteristics  Unlike other units (feature \u0026amp; operation), jobs don\u0026rsquo;t call other jobs to avoid obscure nested logic that end up being hard to follow and maintain. Jobs do not know about other units, they operate in isolation and are unaware of their surroundings. If they were people, they would\u0026rsquo;ve been called selfish for only being concerned with themselves and their needs to perform their task. Constructor parameters of a job - a.k.a. job signature - should be about the job itself only, not concerned with where it will be called from and in which conditions. Here\u0026rsquo;s a personification of a Job speaking: I, as a Job, in order to fulfill my task, I need \u0026ldquo;X\u0026rdquo; and \u0026ldquo;Y\u0026rdquo;, and once I am done I will return \u0026ldquo;Z\u0026rdquo; to you.\n   To validate your choice with jobs, simply ask yourself: \u0026ldquo;what does this job do?\u0026quot; and the answer should be \u0026ldquo;It [does this] then returns [that]\u0026quot; where:\n [does this]: should not include an \u0026ldquo;and\u0026rdquo; and should be made up of few words (single responsibility) [that]: ideally should either be an object, or a status response (boolean). TIP: Avoid returning associative arrays as much as possible, or at all if possible. They ramp up undefined structures and it will require more cognitive load over time to figure out their structures and values.\n   It is common practice to share jobs, in fact they are the units that are shared the most in code. For that reason we strive to make their code cover the entire spectrum of the task they perform, while careful not to end up having complex jobs just for the sake of reusing them.\nGood balance between complexity and functionality is key with jobs, it gets better with time and the more you familiarize yourself with Lucid!\nGenerate Job Class Use lucid CLI to generate a Job class that extends Lucid\u0026rsquo;s Job base class by default, which handle method is invoked when run by an Operation, Feature or a custom dispatcher.\nMicro Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Domains/Product/Tests/FindProductJobTest.php\nMonolith Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at src/Domains/Product/Jobs/FindProductJob.php\nand its test at src/Domains/Product/Tests/FindProductJobTest.php\n The generated Job class will automatically be suffixed with Job, so there\u0026rsquo;s no need for it to be specified in the command.\n For more details on this command see the help manual with lucid make:job --help\n Calling Jobs Jobs are called using the run method that\u0026rsquo;s provided by extending one of Lucid\u0026rsquo;s runner units Feature \u0026amp; Operation classes, which internally relies on a combination of the traits JobDispatcherTrait, MarshalTrait and DispatchesJobs.\nSignature\nrun($job, $arguments = [], $extra = [])\n $job can be either a Job instance or the job\u0026rsquo;s class name (usually using SomeJob::class) [$arguments] is the associative array of arguments mapping the Job\u0026rsquo;s constructor parameters. Only used when $job is the class name and not the instance. [$extra] is for the Laravel dispatcher and is not used by Lucid for any purposes, passed straight to the dispatcher.  Dispatching Jobs \u0026amp; Arguments \nGiven this sample job that updates a product\u0026rsquo;s info in the database:\nnamespace App\\Domains\\Product\\Jobs; class UpdateProductDetailsJob extends Job { public function __construct(int $id, string $title, string $price, string $description) { $this-\u0026gt;id = $id $this-\u0026gt;title = $title $this-\u0026gt;price = $price $this-\u0026gt;description = $description } public function handle(): bool { $product = Product::find($this-\u0026gt;id); $product-\u0026gt;fill([ \u0026#39;title\u0026#39; =\u0026gt; $this-\u0026gt;title, \u0026#39;price\u0026#39; =\u0026gt; $this-\u0026gt;price, \u0026#39;description\u0026#39; =\u0026gt; $this-\u0026gt;description, ]); return $product-\u0026gt;save(); } } Calling this job from a feature or an operation is straight forward using run():\n$this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;id\u0026#39;), \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), ]); $arguments are sent as an associative array where the key should match parameters' names exactly, but not their order. Meaning that we could tangle parameter order, reducing the amount of change required when updating the job with new order of arguments or additional optional ones.\nThis would still work:\n$this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;id\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;id\u0026#39;), ]); Also, aesthetically allows to organize parameters by length which is nicer to look at!\n This is the recommended way of calling jobs, for it makes reading run statements in features and operations explicit and requires a reduced amount of knowledge, which preserves mental space for what actually matters.\n Dispatching Job Instances\nGiven this simple job that retrieves a user from the DB by their identifier:\nnamespace App\\Domains\\User\\Jobs; class GetUserJobID extends Job { private int $id; public function __construct(int $id) { $this-\u0026gt;id = $id; } public function handle() { return User::find($this-\u0026gt;id); } } We can simply initialize an instance and run it:\n$this-\u0026gt;run(new GetUserByIDJob($userId)); and it works exactly the same as if we did run(GetUserByIDJob::class, ['id' =\u0026gt; $userId]).\n $arguments won\u0026rsquo;t apply when an initialized job is run.\n Since the job requires only one argument, and looking at the run line is intuitively indicative of the intended functionality and the argument, we can simply initialize the job ourselves and pass it to the dispatcher.\nThis is familiar with jobs that are known to (almost) never need to evolve beyond their initial functionality, and is surely not recommended when the job requires two or more parameters because of the extra effort required to figure out the parameters when reading run statements.\nTake for the example the case of a job with more parameters:\n$this-\u0026gt;run(new UpdateProductDetailsJob($id, $title, $description, $price)) instead of this:\n$this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $id, \u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description, \u0026#39;price\u0026#39; =\u0026gt; $price, ]) Choosing Between Initialization \u0026amp; Separate Arguments\nAs mentioned above, it is recommended to always call with arguments separately instead of initializing jobs externally, because it makes code easier to read when there are multiple jobs in a sequence.\nHere\u0026rsquo;s a comparison of the two approaches in the following handle method, could be for a feature or an operation:\nSeparate: A bit more writing but clearer when reading.\npublic function handle(Request $request) { $this-\u0026gt;run(ValidateProductInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input(), ]); $photos = $this-\u0026gt;run(UploadProductPicturesJob::class, [ \u0026#39;cover\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;pictures.cover\u0026#39;), \u0026#39;showcase\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;pictures.showcase\u0026#39;), ]); $product = $this-\u0026gt;run(CreateProductJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;provider\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;provider\u0026#39;), \u0026#39;photos\u0026#39; =\u0026gt; $photos ]); $isStockUpdated = $this-\u0026gt;run(UpdateProductStockAvailabilityJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $product-\u0026gt;id, \u0026#39;available_count\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;available_count\u0026#39;), ]); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;data\u0026#39; =\u0026gt; $product, \u0026#39;template\u0026#39; =\u0026gt; \u0026#39;product.update\u0026#39;, ]); } Initialized: Fast to write but harder to read.\npublic function handle(Request $request) { $this-\u0026gt;run(new ValidateProductInputJob($request-\u0026gt;input)); $photos = $this-\u0026gt;run(new UploadProductPicturesJob( $request-\u0026gt;input(\u0026#39;pictures.cover\u0026#39;), $request-\u0026gt;input(\u0026#39;pictures.showcase\u0026#39;)) ); $product = $this-\u0026gt;run(new CreateProductJob( $request-\u0026gt;input(\u0026#39;title\u0026#39;), $request-\u0026gt;input(\u0026#39;price\u0026#39;), $request-\u0026gt;input(\u0026#39;description\u0026#39;), $request-\u0026gt;input(\u0026#39;provider\u0026#39;), $photos) ); $isStockUpdated = $this-\u0026gt;run(new UpdateProductStockAvailabilityJob( $product-\u0026gt;id, $request-\u0026gt;input(\u0026#39;available_count\u0026#39;)); } Queuable Jobs You may turn any job into a queueable job that will be dispatched using Laravel Queues rather than running synchronously, by simply implementing ShouldQueue interface.\nGenerate Queueable Job lucid make:job UploadPhotos files --queue Will produce the following job class:\nclass UploadPhotosJob extends Job implements ShouldQueue { public function handle() { // photo uploads will be processed in the queue  } } This job will be treated exactly as Laravel treats queued jobs.\nSpecify Queue Name public function __construct() { /* * set the name of the queue on which to dispatch this job. * if using Horizon, this should be the same as the one configured there. */ $this-\u0026gt;onQueue(\u0026#39;emails\u0026#39;); } Custom Dispatcher You may turn any class in your application into a dispatcher of jobs. To equip a class for running jobs, these traits are required: JobDispatcherTrait, MarshalTrait and DispatchesJobs.\nclass Handler extends ExceptionHandler { use MarshalTrait; use DispatchesJobs; use JobDispatcherTrait; } Handling Errors with Jobs It is common to want to dispatch jobs from Exceptions\\Handler, where you may want to centralize your error responses in jobs to maintain a consistent structure across your application.\nAssuming that we are working on an API where all our errors must be returned in JSON format, to avoid the accidental rendering of an HTML page leading to unexpected behaviours. We would create a job to be run when encountering an exception that includes the response structure. Lucid ships with one that can be used as default, available in the built-in Http domain App\\Domains\\Http\\Jobs\\RespondWithJsonErrorJob which has a simple signature:\n$this-\u0026gt;run(RespondWithJobErrorJob::class, [ \u0026#39;message\u0026#39; =\u0026gt; $e-\u0026gt;getMessage(), \u0026#39;code\u0026#39; =\u0026gt; 2900, // custom error code, optional, default: 400  \u0026#39;status\u0026#39; =\u0026gt; 400, // HTTP response status code, optional, default: 400  \u0026#39;headers\u0026#39; =\u0026gt; [], // customize headers  \u0026#39;options\u0026#39; =\u0026gt; 0, // will be passed to ResponseFactory::json() ]); Running this job in response to our exceptions will guarantee that the consumer always receives a consistent JSON structure:\n{ \u0026#34;status\u0026#34;: 400, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: 2900, \u0026#34;message\u0026#34;: \u0026#34;Expressive message about the error.\u0026#34; } } Rendering Exceptions In our Handler class we can register a custom rendering Closure for exceptions of a given type and use the job to render JSON.\nuse App\\Exceptions\\CustomException; /** * Register the exception handling callbacks for the application. * * @return void */ public function register() { $this-\u0026gt;renderable(function (CustomException $e, $request) { return $this-\u0026gt;run(RespondWithJsonErrorJob::class, [ \u0026#39;status\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; $e-\u0026gt;getMessage(), ]); }); } You may also wish to return a view in the case of an HTML response instead:\nuse App\\Exceptions\\CustomException; /** * Register the exception handling callbacks for the application. * * @return void */ public function register() { $this-\u0026gt;renderable(function (CustomException $e, $request) { return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;status\u0026#39; =\u0026gt; 500, \u0026#39;template\u0026#39; =\u0026gt; \u0026#39;errors.custom\u0026#39;, ]); }); } Reportable \u0026amp; Renderable Exceptions Similar to our Handler class, we may have our exceptions render themselves by defining render method in the exception class.\nnamespace App\\Exceptions; use Exception; class RenderException extends Exception { use MarshalTrait; use DispatchesJobs; use JobDispatcherTrait; /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function render($request) { return $this-\u0026gt;run(RespondWithJsonErrorJob::class, [ \u0026#39;status\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; $this-\u0026gt;getMessage(), ]); } } Testing When generating a job with lucid make:job a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nTheir locations help us encapsulate our domains since they would contain all they need to operate in isolation.\nMicro lucid make:job UpdateProductDetails product Would generate two files:\n app/Domains/Product/Jobs/UpdateProductDetailsJob app/Domains/Product/Tests/Jobs/UpdateProductDetailsJobTest  Monolith lucid make:job UpdateProductDetails product Would generate two files:\n src/Domains/Product/Jobs/UpdateProductDetailsJob src/Domains/Product/Tests/Jobs/UpdateProductDetailsJobTest   The example below illustrates a simplified version of testing user input validation job:\nnamespace App\\Domains\\User\\Tests\\Jobs; use Tests\\TestCase; use Lucid\\Foundation\\InvalidInputException; use App\\Domains\\User\\Jobs\\ValidateUserProfileInputJob; class ValidateUserProfileInputJobTest extends TestCase { public function test_passes_validation() { $data = [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;john@example.com\u0026#39;, \u0026#39;occupation\u0026#39; =\u0026gt; \u0026#39;Fun Seeker\u0026#39;, ]; $job = new ValidateUserProfileInputJob($data); $isValid = $job-\u0026gt;handle(); $this-\u0026gt;assertTrue($isValid); } public function test_fails_with_empty_name() { $this-\u0026gt;expectException(InvalidInputException::class); $this-\u0026gt;expectExceptionMessage(\u0026#39;The name field is required.\u0026#39;); $invalid = [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;john@example.com\u0026#39;, \u0026#39;occupation\u0026#39; =\u0026gt; \u0026#39;Fun Seeker\u0026#39;, ]; $job = new ValidateUserProfileInputJob($invalid); $job-\u0026gt;handle(); } } Mocking In most cases you wouldn\u0026rsquo;t want to mock with jobs because they are the actual units of work that need to be tested, though there would still be cases where you must mock. E.g. fetching content from an external source as illustrated in the example below, where we have a job to fetch articles from dev.to to test.\nOur job looks like this:\nnamespace App\\Domains\\DevTo\\Jobs; use Lucid\\Foundation\\Job; use App\\Domains\\DevTo\\Client; use Illuminate\\Support\\Collection; class FetchDevToArticlesJob extends Job { public function handle(Client $devto): Collection { $articles = $devto-\u0026gt;articles(); return collect($articles); } } Client class code has been omitted, needless to say it is where the connection to dev.to happens to retrieve the articles:\nTest\nnamespace App\\Domains\\DevTo\\Tests\\Jobs; use Mockery; use Tests\\TestCase; use App\\Domains\\DevTo\\Client; use Illuminate\\Support\\Collection; use App\\Domains\\DevTo\\Jobs\\FetchDevToArticlesJob; class FetchDevToArticlesJobTest extends TestCase { public function test_fetch_dev_to_articles_job() { $expected = json_encode([ \u0026#39;expected\u0026#39; =\u0026gt; \u0026#39;response\u0026#39;, \u0026#39;goes\u0026#39; =\u0026gt; \u0026#39;here\u0026#39;, ], true); // mock client  $mClient = Mockery::mock(Client::class); $mClient-\u0026gt;shouldReceive(\u0026#39;articles\u0026#39;)-\u0026gt;withNoArgs()-\u0026gt;andReturn($expected); $job = new FetchDevToArticlesJob(); // execute job with injected mocked client  $articles = $job-\u0026gt;handle($mClient); $this-\u0026gt;assertInstanceOf(Collection::class, $articles); } } "},{"uri":"http://docs.lucidarch.dev/operations/","title":"Operations","tags":[],"description":"","content":"Their purpose is to increase the degree of code reusability by piecing jobs together to provide composite functionalities from across domains.\n Operations are a group of jobs that deliver multi-step functionalities. Technically, Operation classes are similar to Feature classes in usage; meaning that they both have run($job,$params) in common to run jobs from any domain, and can be called standalone (e.g. call an operation from a Command).\nHowever, conceptually they have their differences in that a Feature can run multiple Operation and Job classes while an Operation can run multiple Jobs only. They also differ in what they represent to the application: A feature is what the application provides to the outside, while an operation is more of an internal aspect. Technically they differ in they way they are dispatched, where we serve a feature but we run an operation; any class can do so the same as a Feature class would by turning it into a dispatcher class.\nExample\nGiven that we are working on a publishing platform, and upon creating an article we would like to send notifications to the subscribers of the author, here\u0026rsquo;s what that operation may look like:\nclass NotifySubscribersOperation extends Operation { private int $authorId; public function __construct(int $authorId) { $this-\u0026gt;authorId = $authorId; } /** * Sends notifications to subscribers. * * @return int Number of notification jobs enqueued. */ public function handle(): int { $author = $this-\u0026gt;run(GetAuthorByIDJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;authorId, ]); do { $result = $this-\u0026gt;run(PaginateSubscribersJob::class, [ \u0026#39;authorId\u0026#39; =\u0026gt; $this-\u0026gt;authorId, ]); if ($result-\u0026gt;subscribers-\u0026gt;isNotEmpty()) { // it\u0026#39;s a queueable job so it will be enqueued, no waiting time  $this-\u0026gt;run(SendNotificationJob::class, [ \u0026#39;from\u0026#39; =\u0026gt; $author, \u0026#39;to\u0026#39; =\u0026gt; $result-\u0026gt;subscribers, \u0026#39;notification\u0026#39; =\u0026gt; \u0026#39;article.published\u0026#39;, ]); } } while ($result-\u0026gt;hasMorePages()); return $result-\u0026gt;total; } } As you see the jobs that are used in this operation are ones that can be shared with other areas in our code as well, increasing the degree of reusable code.\n  GetAuthorByIDJob: to retrieve a user/author by ID is as abstract as it can get, and will definitely be used numerous times in our application.\n  PaginateSubscribersJob: would be used every time we need to retrieve an author\u0026rsquo;s subscribers. Such jobs usually grow in responsibility over time and their results become more customizable.\nExample: later it may allow to specify a certain limit to the number of subscribers to return, then we\u0026rsquo;d be able to paginate them for listing subscribers in a view or over an API.\n  SendNotificationJob: will be used every time we need to send a notification, regardless of the type of notification to be sent since it is specified with the notification parameter. Which also can grow into providing more customization such as specifying the type of notification to send (e.g. mobile, browser, web, email etc.).\n  With this we\u0026rsquo;ve achieved single responsibility at a low cost of debt and prepared for scale. In fact, some of these jobs would\u0026rsquo;ve been implemented already by the time we reached this operation which makes it quick to biuld.\nNow we have that functionality bundled at our disposal to be called whenever needed:\n$this-\u0026gt;run(NotifySubscribersOperation::class, [ \u0026#39;authorId\u0026#39; =\u0026gt; $authorId, ]); Generate Operation Class Use lucid CLI to generate an Operation class that extends Lucid\u0026rsquo;s Operation base class by default, which handle method is invoked when run by a Feature or a custom dispatcher.\nMicro Signature\nlucid make:operation \u0026lt;operation\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers Generated class will be at app/Operations/NotifySubscribersOperation.php\nand its test at tests/Operations/NotifySubscribersOperationTest.php\nMonolith Signature\nlucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers publishing Generated class will be at src/Services/Publishing/Operations/NotifySubscribersOperation.php\nand its test at src/Services/Publishing/Tests/Operations/NotifySubscribersOperationTest.php\n The generated Operation class will automatically be suffixed with Operation, so there\u0026rsquo;s no need for it to be specified in the command.\nCalling Operations Similar to jobs, and Operation can also be called using the run method that\u0026rsquo;s provided by extending one Lucid\u0026rsquo;s Feature or a custom dispatcher,\nSee here for more on the run method.\nclass PublishArticleFeature extends Feature { $this-\u0026gt;run(new ValidateArticlePublishingInputJob($request-\u0026gt;input())); $this-\u0026gt;run(SetArticlePublishingRulesOperation::class, [ \u0026#39;id\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;id\u0026#39;), \u0026#39;schedule\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;datetime\u0026#39;), \u0026#39;platforms\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;platforms\u0026#39;), \u0026#39;visibility\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;visibility\u0026#39;), ]); $this-\u0026gt;run(NotifySubscribersOperation::class, [ \u0026#39;authorId\u0026#39; =\u0026gt; Auth::id(), ]); $article = $this-\u0026gt;run(new GetArticleByIDJob($request-\u0026gt;input(\u0026#39;id\u0026#39;))); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;article\u0026#39;), \u0026#39;template\u0026#39; =\u0026gt; \u0026#39;articles.publish.success\u0026#39;, ]); } Queueable Operations You may turn any operation into a queueable operation that will be dispatched using Laravel Queues rather than running synchronously, by simply implementing ShouldQueue interface.\nGenerate Queueable Operation Use the --queue or shorthand -Q to generate a queueable operation.\nlucid make:job NotifySubscribers --queue Will produce the following operation class:\nclass NotifySubscribersOperation extends Operation implements ShouldQueue { public function handle() { // notifications processing will happen in the queue  } } This job will be treated exactly as Laravel treats queued jobs.\nSpecify Queue Name public function __construct() { /* * set the name of the queue on which to dispatch this operation. * if using Horizon, this should be the same as the one configured there. */ $this-\u0026gt;onQueue(\u0026#39;notifications\u0026#39;); } Testing When generating an operation with lucid make:operation a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nMicro lucid make:operation NotifySubscribers Would generate two files:\n app/Operations/NotifySubscribersOperation.php tests/Operations/NotifySubscribersOperationTest.php  Monolith lucid make:operation NotifySubscribers publishing Would generate two files:\n src/Services/Publishing/Operations/NotifySubscribersOperation.php src/Services/Publishing/Tests/Operations/NotifySubscribersOperationTest.php   The purpose of operation testing is to ensure that the integration between the jobs it runs is working as expected, but we do not have to test every job\u0026rsquo;s case on its own, for that we rely on jobs being tested for their integrity.\nFor example, consider the following operation test:\n\u0026lt;?php namespace App\\Services\\Publishing\\Tests\\Operations; use Tests\\TestCase; use App\\Data\\Models\\Author; use App\\Data\\Models\\Subscriber; use Illuminate\\Support\\Facades\\Queue; use App\\Services\\Operations\\NotifySubscribersOperation; class NotifySubscribersOperationTest extends TestCase { public function test_successfully_notifying_subscribers() { // SendNotificationJob will be dispatched to the queue  Queue::fake(); // queue must be empty  Queue::assertNothingPushed(); // n. of subscribers we\u0026#39;re testing with  $subscribers = 10; $author = Author::factory() -\u0026gt;has(Subscriber::factory($subscribers)); -\u0026gt;create(); $op = new NotifySubscribersOperation($author-\u0026gt;id); $result = $op-\u0026gt;handle(); // assert all subscribers were paginated  $this-\u0026gt;assertEquals($subscribers, $result); // assert the correct n. of SendNotificationJob were dispatched  Queue::assertPushed(SendNotificationJob::class, $subscribers); } } Mocking Jobs When testing, you may occasionally need to skip dispatching a certain job but would still want to make sure that the operation actually ran the job as expected, with the correct parameters. In such cases we would mock the operation\u0026rsquo;s run partially.\nIn our case we\u0026rsquo;d update our test to not dispatch SendNotificationJob so that we don\u0026rsquo;t actually send notifications. This may seem odd at first because we are mocking the class that we are actually testing, but with partial mocks only the methods that we set expectations on would be mocked and the rest would be dispatched. And in case the operation doesn\u0026rsquo;t call run(SendNotificationJob::class, $params) with the expected parameters the test will fail.\n\u0026lt;?php namespace App\\Services\\Publishing\\Tests\\Operations; use Mockery; use App\\Data\\Models\\Author; use App\\Data\\Models\\Subscriber; use App\\Services\\Operations\\NotifySubscribersOperation; class NotifySubscribersOperationTest extends TestCase { public function test_successfully_notifying_subscribers_with_mock() { // n. of subscribers we\u0026#39;re testing with  $subscribers = 10; $author = Author::factory() -\u0026gt;has(Subscriber::factory($subscribers)); -\u0026gt;create(); // create operation mock instance  $mOp = Mockery::mock(NotifySubscribersOperation::class, [$author-\u0026gt;id]); // set expectations to jobs that need to be skipped  $mOp-\u0026gt;shouldReceive(\u0026#39;run\u0026#39;) -\u0026gt;with(SendNotificationJob::class, [ \u0026#39;from\u0026#39; =\u0026gt; $author, \u0026#39;to\u0026#39; =\u0026gt; $author-\u0026gt;subscribers, \u0026#39;notification\u0026#39; =\u0026gt; \u0026#39;article.published\u0026#39;, ]); $result = $mOp-\u0026gt;handle(); // assert all subscribers were paginated  $this-\u0026gt;assertEquals($subscribers, $result); } } Whether to mock or not is a case-by-case decision, but as a general guideline it is best to always test with what\u0026rsquo;s closest to reality.\n"},{"uri":"http://docs.lucidarch.dev/cli/","title":"CLI Reference","tags":[],"description":"","content":"The lucid command line interface companion for the Lucid Architecture.\nlucid is a set of methods to easily manage [create, delete] Lucid units such as Jobs, Operations, Features as well as Laravel\u0026rsquo;s own components such as Controller, Eloquent Model, Request and Policy; ensuring that they go where they belong and are generated with their test companion classes.\n Setup The executable binary can be found at ./vendor/bin/lucid after requiring lucid-arch/console.\nFor convenience you might want to address lucid directly instead of having to go through ./vendor/bin every time. To do that you need to add ./vendor/bin to your shell session\u0026rsquo;s $PATH. For the current session, run:\nexport PATH=\u0026#34;./vendor/bin:$PATH\u0026#34; However, it will only be available for the current session. To make it permanent, add it to your shell profile (~/.bash_profile, ~/.bashrc, ~/.zshrc) and you will be able to simply call lucid from the application\u0026rsquo;s root directory.\nUse list to view a list of all available commands:\nlucid list Also, just like in Artisan, every command includes a \u0026ldquo;help\u0026rdquo; screen describes the command\u0026rsquo;s available arguments and options. To view a help screen, precede the name of the command with help or use the --help option:\nlucid help make:feature # or lucid make:feature --help Commands src:name Set the root namespace.\nlucid src:name \u0026lt;namespace\u0026gt;  make:service  For Monolith projects only.\n Create a new service in a monolith project.\nlucid make:service \u0026lt;name\u0026gt; # example lucid make:service HumanResources Will generate the following structure:\nsrc ‚îî‚îÄ‚îÄ Services ‚îî‚îÄ‚îÄ HumanResources ‚îú‚îÄ‚îÄ Providers ‚îú‚îÄ‚îÄ Console ‚îú‚îÄ‚îÄ Http ‚îú‚îÄ‚îÄ Features ‚îú‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ Tests ‚îú‚îÄ‚îÄ database ‚îú‚îÄ‚îÄ routes ‚îî‚îÄ‚îÄ resources  make:controller Generate a controller class.\nMicro Signature\nlucid make:controller \u0026lt;controller\u0026gt; Example\nlucid make:controller Article Generated class will be at app/Http/Controllers/ArticleController.php\nMonolith Signature\nlucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:controller Article Publishing Generated class will be at src/Services/Publishing/Http/Controllers/ArticleController.php\n Empty Controller\nBy default it will generate a RESTful controller with preset methods. To generate an empty controller use the --plain option:\nlucid make:controller \u0026lt;controller\u0026gt; [\u0026lt;service\u0026gt;] --plain  make:feature Generate a Feature class.\nMicro Signature\nlucid make:feature \u0026lt;feature\u0026gt; Example\nlucid make:feature ListProducts Generated class will be at app/Features/ListProductsFeatures.php\nand its test at tests/Features/ListProductsFeaturesTest.php\nMonolith Signature\nlucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:feature ListProducts Commerce Generated class will be at src/Services/Commerce/Features/ListProductsFeatures.php\nand its test at src/Services/Commerce/Tests/Features/ListProductsFeaturesTest.php\n The generated Feature class will automatically be suffixed with Feature, so there\u0026rsquo;s no need for it to be specified in the command.\n make:job Generate a Job class.\nMicro Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Domains/Product/Tests/FindProductJobTest.php\nMonolith Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at src/Domains/Product/Jobs/FindProductJob.php\nand its test at src/Domains/Product/Tests/FindProductJobTest.php\n The generated Job class will automatically be suffixed with Job, so there\u0026rsquo;s no need for it to be specified in the command.\n make:operation Micro Signature\nlucid make:operation \u0026lt;operation\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers Generated class will be at app/Operations/NotifySubscribersOperation.php\nand its test at tests/Operations/NotifySubscribersOperationTest.php\nMonolith Signature\nlucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers publishing Generated class will be at src/Services/Publishing/Operations/NotifySubscribersOperation.php\nand its test at src/Services/Publishing/Tests/Operations/NotifySubscribersOperationTest.php\n The generated Operation class will automatically be suffixed with Operation, so there\u0026rsquo;s no need for it to be specified in the command.\n make:migration Micro Signature\nlucid make:migration \u0026lt;migration\u0026gt; Example\nlucid make:migration create_articles_table Generated file will be at database/migrations/2020_10_28_180253_create_articles_table.php\nMonolith Signature\nlucid make:migration \u0026lt;migration\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:migration create_articles_table publishing Generated file will be at src/Services/Publishing/database/migrations/2020_10_28_180253_create_articles_table.php\n  make:model Generate an Eloquent model class.\nSignature\nlucid make:model \u0026lt;name\u0026gt; Example\nlucid make:model Product Generated model file will be at [app|src]/Data/Product.php.\n make:request Micro lucid make:request \u0026lt;request\u0026gt; Generated file will be at app/Http/Requests/\u0026lt;request\u0026gt;.\nMonolith lucid make:request \u0026lt;request\u0026gt; \u0026lt;service\u0026gt; Generated file will be at src/Services/\u0026lt;service\u0026gt;/Http/Requests/\u0026lt;request\u0026gt;.\n  make:policy Micro lucid make:policy \u0026lt;policy\u0026gt; Generated file will be at app/Http/Policies/\u0026lt;policy\u0026gt;.\nMonolith lucid make:policy \u0026lt;policy\u0026gt; \u0026lt;service\u0026gt; Generated file will be at src/Services/\u0026lt;service\u0026gt;/Http/Policies/\u0026lt;policy\u0026gt;.\n  list:services List the services in a monolith project\n For Monolith projects only.\n lucid list:services +------------+------------+-------------------------+ | Service | Slug | Path | +------------+------------+-------------------------+ | Commerce | commerce | src/Services/Commerce | | Publishing | publishing | src/Services/Publishing | | Admin | admin | src/Services/Admin | +------------+------------+-------------------------+  list:features lucid list:features +---------------------------------+---------+-----------------------------------------+----------------------------------------------------------------------+ | Feature | Service | File | Path | +---------------------------------+---------+-----------------------------------------+----------------------------------------------------------------------+ | Update DevTo Collaborations | Digest | UpdateDevToCollaborationsFeature.php | src/Services/Digest/Features/UpdateDevToCollaborationsFeature.php | | Update DevTo Articles | Digest | UpdateDevToArticlesFeature.php | src/Services/Digest/Features/UpdateDevToArticlesFeature.php | | Add GitHub Repo To Digest | Digest | AddGitHubRepoToDigestFeature.php | src/Services/Digest/Features/AddGitHubRepoToDigestFeature.php | | Lookup GitHub Repo | Digest | LookupGitHubRepoFeature.php | src/Services/Digest/Features/LookupGitHubRepoFeature.php | | Person Feed | Digest | PersonFeedFeature.php | src/Services/Digest/Features/PersonFeedFeature.php | | Update Stack Overflow Questions| Digest | UpdateStackOverflowQuestionsFeature.php | src/Services/Digest/Features/UpdateStackOverflowQuestionsFeature.php | | Update GitHub Data | Digest | UpdateGitHubDataFeature.php | src/Services/Digest/Features/UpdateGitHubDataFeature.php | | Login With GitHub | Digest | LoginWithGitHubFeature.php | src/Services/Digest/Features/LoginWithGitHubFeature.php | +---------------------------------+---------+-----------------------------------------+----------------------------------------------------------------------+ delete:service  For Monolith projects only.\n lucid delete service \u0026lt;name\u0026gt; delete:feature lucid delete:feature \u0026lt;feature\u0026gt; [\u0026lt;service\u0026gt;] delete:job lucid delete:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; delete:model delete:model \u0026lt;model\u0026gt; delete:request lucid delete:request \u0026lt;request\u0026gt; [\u0026lt;service\u0026gt;] delete:policy delete:policy \u0026lt;policy\u0026gt; [\u0026lt;service\u0026gt;] "}]