[{"uri":"https://docs.lucidarch.dev/introduction/","title":"Introduction","tags":[],"description":"","content":"Software architecture to build services that last with minimum technical dept; based on proven principles and practical guidelines.\n The Motive Developing large-scale applications has always been easy to think about but when it comes to implementation lots of questions arise especially when working in a collaborative team where every decision is peer-discussed and made over coffee or beer on a napkin. Some of these discussions go around fundamental subjects such as:\n Where should this good piece of art code reside (folder, file, class, etc.)? How should we apply these sets of design patterns to implement this feature? How can you describe the underlying architecture that is running‚Ä¶ EVERYTHING!?  Asking such questions is a brilliant start, knowing that every project or product we start working on starts from a mere idea - a spark - to help fulfil a human function. Nevertheless, deep in the back of our heads we know that at some point in the future it will grow and we don\u0026rsquo;t want it to grow on us, we\u0026rsquo;d rather have it grow with us. Especially in an agile culture we want the pieces of our applications to be easily interchangeable with the least friction possible and keeping technical debt to a minimum.\nWhat is an architecture anyway? But a pattern of connected structures cooperating according to a set of guidelines and principles to serve their purpose.\nFrom that sentence, Lucid will be the practical set of guidelines and principles to build backend services that last.\nThe following questions will also help ensure that you should incorporate Lucid in your current or upcoming project:\n Have you ever been onboarded to a code that is completely custom to the point that it Have you seen a Laravel project, even though it has been provided with Laravel\u0026rsquo;s impeccable simplicity, somehow managed to be ruined by endless whirlpools of huge controllers and deeply dependant and connected classes?  These situations and many more are best described in the following picture, which analogy is our application in a few months time.\n  Technical debt due to intertwined object relationships in a legacy application.  If you would like the image above to become something as below\u0026hellip;\n  Clear and precise composition of objects.  ¬†You\u0026rsquo;re in the right place! Lucid ‚Ä¢ Laravel Within controllers and commands, our application is prone to disorder due to the high degree of autonomy in MVC. Lucid fills that gap to complete the chain of Laravel\u0026rsquo;s MVC framework.\nThe relationship between Laravel and Lucid is that they complete each other. Lucid will be the bond between the application\u0026rsquo;s entry points and the units that do the actual work (classes, interfaces, design patterns etc.) securing code from meandering in drastic directions.\nIn fact, the very first announcement of Lucid to the public was in Laracon EU 2016 two years after its in-house use. See video below if you would like to watch the announcement:\n  Abed Halawi - The lucid architecture for building scalable applications - Laracon EU 2016  The Architecture At a glance\u0026hellip;\nFramework Provides the ‚Äúkernel‚Äù, request/response lifecycle, dependency injection and the core functionalities for the Foundation to build on. Knows nothing about the application logic. All this with the power of Laravel.\nFoundation Provides support to the concrete units of the architecture (services, domains and data) by extending the framework with fundamental (abstract) classes; due to that, and the fact that the concrete units will only deal with the foundation, any change at the framework level will be transparent and have the least effect possible on the application overall and as a result the Lucid architecture grants a reduced amount of technical debt in the case of a drastic update/upgrade or even migration to another framework.\nExamples of what the Foundation might include:\n FoundationController to be extended by the controllers in services Entity class that extends a base class such as an Eloquent model Decorators for validation, authentication and other fundamental yet shared functionality  Services They implement the features but do not implement the logic of the feature themselves, their responsibility is to compose Jobs and Operations from Domains. Think of a Job as a step if the feature was a user story; and an Operation is a group of steps that are often executed together to accomplish a single purpose.\nExample: a project consisting of an API and an Admin where you would implement each in its own scope for separation of concerns yet use common code between them using Domains and Data.\n Terminology\nThe terminology of a service is used in the form of ‚ÄúOur application provides data through an API service, it also has an Admin service with a user interface to perform advanced data manipulation procedures.\nHierarchy\nThe hierarchy of services and their units is as described in the pyramid below, given the example of an HTTP request:\nDomains They implement the business logic and expose them through jobs, they are isolated and MUST NOT inter-communicate [no domain calls another]. Their objective is to categories the jobs that accomplish unit-level tasks in our application within a definite scope.\nExample: in a task management app there‚Äôs the User domain and Task domain each having its own validators, generators, builders, factories, utility classes etc. and they utilise the data layer to perform data-specific procedures in addition to Jobs that are (favourably) the only way to communicate with domains. Potential Jobs in a task management app in the Task domain could be: SaveTaskJob, MarkTaskCompletedJob, AssignTaskToUserJob , where each of these is a class of its own. More on Jobs in Definitions.\n We suffix Job classnames with Job for readability and easier navigation, also extending the PSR-2 coding standard of suffixing interfaces with Interface, Feature with Feature and Operation with Operation.\n Data Owns the data (duh!), which means models (entities), repositories, value objects, enums\u0026hellip; you name it. You may be asking why separate the data layer from the domains layer? aren‚Äôt they related? The answer is of course they are! Yet domains remain to be isolate, self-satisfied and no cross-domain relationships exist while data is organically related; if we included them in domains we would‚Äôve ended up working with cross-domain dependencies which defies the idea of domains being self-contained.\nAnother reason for having a separate data layer is the trend of the 21st centry: üí´data science‚ú® which makes this layer the place for your¬†statistics and analytics algorithms, a central layer for the elements of data.\nPrinciple: Domains, Jobs and Operations are isolated classes with single responsibilities, they perform one thing and one thing only; no inter-domain, inter-job or inter-operation dependencies should exist whatsoever.\n Congratulations for making it thus far! It may feel a little rough though, and that\u0026rsquo;s why there is more to these concepts for you to dig into.\n"},{"uri":"https://docs.lucidarch.dev/philosophy/","title":"Philosophy","tags":[],"description":"","content":"Throughout our careers as engineers we encounter numerous similar tasks disguised in different forms, maybe having slight differences. Every time we encounter the same task, we think it through based on our previous accomplishment of the task and figure out a better way to do it according to our gained experience. In the field of science, this is the natural progression of the learning experience - trial and error. Nevertheless, many have tried before us and have passed best practices that we [as a community] adopted as principles and guidelines to become an organic extension of our workflow, intrinsically applying them with little thinking effort.\nLucid is not any different, it is an amalgamation of experiences in building scalable products to serve various industries by interchangeable teams. Based on the many mistakes we\u0026rsquo;ve made and the suffering we\u0026rsquo;ve had when we go back to a \u0026ldquo;legacy\u0026rdquo; project, or during the onboarding process of someone new to the team, where the training process cannot keep up with the variety of opinions that\u0026rsquo;s been implemented in different projects, regardless of whether they\u0026rsquo;re right or wrong, they are many and have no single basis, a foundation, or an single architecture.\nWe wanted something simple [KISS] yet effective at scale. Enjoyable to work with by all levels of engineers alike. And elevates the level of understanding abstraction throughout its steep learning process. Simply put:\n\u0026nbsp;\u0026nbsp;Lucid is a set of principles that depend on our discipline to preserve\u0026nbsp;\u0026nbsp;   Name \u0026ldquo;Expressed clearly; easy to understand\u0026rdquo; marks the ultimate objective that the architecture intends to achieve in code.\n  Emblem    Foundation The more you look at it, the different shapes you will see. Some of these shapes may seem like a building or a block and they go in different directions. However, they are all starting from the same center - The Foundation.\nResilience From it emerges lines that have equal height, though go in different directions but have similar characteristics - representing the malleability of Lucid. Though, without guidelines and principles the outcome will not be desirable. Hence the straight lines that go in one and only one direction, representing the responsibility of each component in our code regardless of its destination.\nDirection The compass was an inspiration to the logo - without it we will surely get lost. Not knowing where we are, in which direction to go and how to go there is even worse. However, if we\u0026rsquo;ve been down the same road before it will be easier to know what should happen next.\nLike a compass, Lucid provides the guidance and acts as a reliable companion to your code navigation journey.\nAlso, a compass has no final destination and is only there to lead us wherever we wish to go, similar to any project that is ever evolving but the compass will never change direction.\nClarity From darkness to light. The dark end of the logo represents the chaos that our projects end up having after a long period of work and re-work, the variety of features they contain along with their changes. Going through the foundation (the center) - in this case Lucid - our projects go out of the other side in light - clear, understandable and easy to work with.\n"},{"uri":"https://docs.lucidarch.dev/principles/","title":"Principles","tags":[],"description":"","content":" Features shall serve a single purpose Favour creating as many of them as you wish rather than complicating a single one.\n Jobs shall perform a single task No job should do two things at a time, it will only get confusing the more you do it.\n Domains shouldn\u0026rsquo;t cross When working within a domain, strive to preserve the boundaries by not using functionality from other domains. If you encounter a case where you should, consider Foundation, Operations and Features by rethinking your design.\n Features shall not call other features Run as many jobs and operations as you like, but never a feature.\n Jobs shall not call other jobs This is your business logic, keep it concise by avoiding nesting hell.\n Operations shall not call other operations Run as many jobs as you like, but never any other unit.\n Controllers serve Features Consistency is key for a successful architecture, and so are thin controllers to a successful MVC application.\n Write code that humans can read Machines will run it nonetheless, it is us who will suffer.\n "},{"uri":"https://docs.lucidarch.dev/routing/","title":"Routing","tags":[],"description":"","content":"Out of the SOLID principles - of which we are disciples - we\u0026rsquo;ve taken Single Responsibility seriously and created components that define the responsibilities beyond an MVC\u0026rsquo;s controller or any other modern application\u0026rsquo;s entry point, be it a route/request or a command. Which is where it is loose and chaos builds its nest. Within a controller we can do anything, and whichever architecture we follow (or don\u0026rsquo;t) we can still create a mess due to not having a specific guideline that helps contain the chaos.\nHere we define the responsibility of each component starting from MVC and moving through Lucid to keep codebase organised, defined and understandable at a glance, supporting whichever design patterns we decide to adopt:\n  Router A router is like a door that one can open to enter a room. A door does not concern itself with what the room contains or what its purpose is. It is simply a door. However, sometimes we have some security pass for the door to open, so a router can be configured to include components that perform security checks and other forms of entrance preparation.\n  Responsibility: Expose a feature from the application over HTTP, routing the request to the corresponding controller method.\nKernel Use Lucid Units (Feature, Job, Operation) to implement your middleware functionality. Code that you may use anywhere else in your application can be easily shared in\n  This space is best to:\n Define the URL you want your application to allow entries through. Define the controller method that should handle the request and serve the Feature. Perform pre-flight / middleware work such as request authorisation, preparation [does not include input validation].  "},{"uri":"https://docs.lucidarch.dev/controllers/","title":"Controllers","tags":[],"description":"","content":"In an effort to minimize the work of controllers, for they are not here to do work for the application but to point the request in the right direction. In Lucid terms, to serve the intended feature to the user.\nEventually we will end up having one line within each controller method, achieving the thinnest form possible.\n  Responsibility: Serve the designated feature.\nWhat you should do in a controller:\n Serve a feature. Prepare input as required by the feature that\u0026rsquo;s being served [does not include input validation]   Generate Controller Class Use lucid CLI to generate a controller that extends Lucid\u0026rsquo;s Controller class by default, which allows us to serve features features using the built-in serve method.\nMicro Signature lucid make:controller \u0026lt;controller\u0026gt;\nExample\nlucid make:controller Article Generated class will be at app/Http/Controllers/ArticleController.php\nMonolith Signature lucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:controller Article Publishing Generated class will be at app/Services/Publishing/Http/Controllers/ArticleController.php\n ¬†For more details on this command see the help manual with lucid make:controller --help or visit make:controller\n Serve Features   To serve a Feature from controllers simply call the serve method provided by Lucid\u0026rsquo;s parent controller.\nuse Lucid\\Units\\Controller; use App\\Features\\UpdateArticleFeature; class ArticleController extends Controller { public function articles() { return $this-\u0026gt;serve(ListArticlesFeature::class); } } Request Input The served feature will be able to inject Request class to access request properties. This keeps our controllers clean and allows us to concentrate on what matters to the feature only.\nclass ListArticlesFeature { public function handle(Request $request) { $input = $request-\u0026gt;input(); // or  $title = $request-\u0026gt;input(\u0026#39;title\u0026#39;); } } Feature Parameters To pass parameters to a feature, we use the same syntax as dispatching a Laravel job:\nuse Lucid\\Units\\Controller; use App\\Features\\UpdateArticleFeature; class ArticleController extends Controller { public function update($id) { return $this-\u0026gt;serve(UpdateArticleFeature::class, [\u0026#39;id\u0026#39; =\u0026gt; $id]); } } The id key will be mapped to $id constructor param UpdateArticleFeature::constructor($id).\n¬†Parameter and constructor variable names must match. And they\u0026rsquo;re case sensitive!\n Using associative arrays as properties has the advantage of disregarding the order in which the parameters are defined in the class we\u0026rsquo;re calling. However, they should be only what the feature needs to operate.\nclass UpdateArticleFeature extends Feature { private $id; public function __construct(string $id) { $this-\u0026gt;id = $id; } public function handle(Request $request) { $this-\u0026gt;run(UpdateArticleDataJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;id, \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;content\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;content\u0026#39;); ]); } } For more on writing features see the Features section.\n"},{"uri":"https://docs.lucidarch.dev/features/","title":"Features","tags":[],"description":"","content":"Represents a human-readable project feature in a class, named the way you would describe it to your colleagues and clients. It contains the logic of implementing the feature with minimum friction and level of detail to remain concise and straight to the point.\nIt runs Lucid Units: Jobs and Operations to perform its tasks. They are thought of as the steps in the process of serving its purpose. A Feature can be served from anywhere, most commonly Controllers and Commands. Can also be queued to run asynchronously using Laravel\u0026rsquo;s powerful Queueing capabilities.\n Technically, it is a class that encapsulates all the functionalities required for a single request/response lifecycle (or command), in which the handle method represents the task list when you want to implement it in your application.\nExample: This is how a Feature class typically looks like. (simplified)\nclass UpdateProductFeature extends Feature { private string $id; public function __construct(string $id) { $this-\u0026gt;id = $id; } public function handle(Request $request) { $this-\u0026gt;run(ValidateProductInputJob::class, $request-\u0026gt;input()); $product = $this-\u0026gt;run(SaveProductJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;id, \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), ]); return $this-\u0026gt;run(new RespondWithJsonJob($product)); } }  ¬†Running Lucid Units asynchronously is as simple as having them implement the Queueable interface, applies to all of units such as Jobs and Operations and Features.\n   Responsibility: Perform the steps required to accomplish the feature by running Jobs and Operations.\nclass UserController extends Controller { public function login() { return $this-\u0026gt;serve(LoginUserFeature::class); } } Generate Feature Class Use lucid CLI to generate a Feature class that extends Lucid\u0026rsquo;s Feature base class by default, which allows us to run jobs and operations using the built-in run method.\nMicro Signature lucid make:feature \u0026lt;feature\u0026gt;\nExample\nlucid make:feature ListProducts Generated class will be at app/Features/ListProductsFeatures.php\nand its test at tests/Features/ListProductsFeaturesTest.php\nMonolith Signature lucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:feature ListProducts Commerce Generated class will be at app/Services/Commerce/Features/ListProductsFeatures.php\nand its test at app/Services/Commerce/Tests/Features/ListProductsFeaturesTest.php\n The generated Feature class will automatically be suffixed with Feature, so the class above will be ListProductsFeature.\n¬†For more details on this command see the help manual with lucid make:feature --help\n Inside Features There are two essential highlights in a feature:\n Signature (a.k.a constructor parameters): Looking at the signature of the Feature should give the idea of what is required for it to be served. handle method: Looking at the class\u0026rsquo;s handle method should provide an overview of the steps required to serve the feature to the user (or any consuming party) without having to know too much details about the inner workings of each step. More on this at below.    class CreateArticleFeature extends Feature { public function handle(Request $request) { $this-\u0026gt;run(new ValidateArticleInputJob($request-\u0026gt;input())); $this-\u0026gt;run(UploadFilesToCDNJob::class, [\u0026#39;files\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;files\u0026#39;)]); $slug = $this-\u0026gt;run(new GenerateSlugJob($request-\u0026gt;input(\u0026#39;title\u0026#39;))); $article = $this-\u0026gt;run(SaveArticleJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;body\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;body\u0026#39;), \u0026#39;slug\u0026#39; =\u0026gt; $slug, ] ); return $this-\u0026gt;run(new RespondWithJsonJob($article)); } } As shown in the example above, there are several ways to run Jobs in features that are explained in details in the definition of Jobs.\n It is recommended to always specify the required parameters in each unit\u0026rsquo;s constructor rather than hiding them within the unit. i.e. pass each input parameter separately rather than the entire $request-\u0026gt;input(), or relying on the unit to inject Request class. This way we keep it clear to know what is required for a job or operation to do its work.\n The handle method Lucid units (Feature, Job, Operation) are simply classes extending Laravel\u0026rsquo;s base Job class with extra functionality that ties them together. Hence, the use of handle method as the invocation point for each of these units.\npublic function handle(Request $request) This method is called automatically when running $this-\u0026gt;serve(Feature::class) and it goes through Laravel\u0026rsquo;s IoC to resolve dependencies. In this example we included the Request class to be resolved so that we can access it and pass input to Jobs. Request could\u0026rsquo;ve been any other class in the application that can be resolved using IoC.\npublic function handle(MyCustomClass $mcc) This is the recommended way of using classes to maintain testability by interchanging class instances with their mocks.\n¬†handle is the same for all Lucid units: Feature, Job and Operation and it behaves the same everywhere.\n Serving Features You may serve features from anywhere in your application! Here are some exapmles of doing so.\nHTTP If your controller is generated through the lucid command, all you need to do is call serve within the controller method, otherwise, have your controller (or parent controller) extend Lucid\u0026rsquo;s controller Lucid\\Units\\Controller.\nuse Lucid\\Units\\Controller; use App\\Features\\UpdateProductsFeature; class ProductController extends Controller { public function products() { return $this-\u0026gt;serve(ListProductsFeature::class); } } Command To run a feature from the command we just need to equip our Command class with Lucid\u0026rsquo;s methods by simply using ServesFeatures\nuse Illuminate\\Console\\Command; use App\\Features\\CleanStaleCartsFeature; use Lucid\\Bus\\ServesFeatures; class CleanStaleCarts extends Command { use ServesFeatures; protected $signature = \u0026#39;clean:carts --stale\u0026#39;; protected $description = \u0026#34;Cleans inactive customer carts.\u0026#34;; public function handle() { return $this-\u0026gt;serve(CleanStaleCartsFeature::class); } } Other Just like we did for Commands we may do the same in any class we want, by simply using ServesFeatures the serve method will be available.\nuse App\\Features\\DoSomethingFeature; use Lucid\\Bus\\ServesFeatures; class ToServeFeaturesHere { use ServesFeatures; public function give() { return $this-\u0026gt;serve(GiveHighFiveFeature::class); } } Testing When generating a feature with lucid make:feature a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nMicro lucid make:feature ListProductsFeature\nWould generate two files:\n app/Features/ListProductsFeature tests/Features/ListProductsFeatureTest  Monolith lucid make:feature ListProductsFeature api\nWould generate two files:\n app/Services/Api/Features/ListProductsFeature app/Services/Api/Tests/Features/ListProductsFeatureTest  Since Monolith is about scope and distribution of responsibility, and features are a scope of a service, tests are distributed and scoped accordingly in the corresponding service.\n Feature tests are equivalent to functional tests in a typical application. It is about testing how the feature would behave with a certain input combination from a user\u0026rsquo;s perspective.\nIf the feature is served over an HTTP request, the test would be about actually requesting the URL and passing parameters to receive the expected output, in addition to further assertions in the case of storage or other application aspects that require further assertion.\nThe example below is incomplete and is for illustrative purposes only (e.g. $fake must be defined).\n class UpdateProductDetailsFeatureTest extends TestCase { public function test_successful_product_details_update() { $product = [ \u0026#39;id\u0026#39; =\u0026gt; $fake-\u0026gt;uuid, \u0026#39;title\u0026#39; =\u0026gt; $fake-\u0026gt;sentence, \u0026#39;description\u0026#39; =\u0026gt; $fake-\u0026gt;text, \u0026#39;price\u0026#39; =\u0026gt; $faker-\u0026gt;randomNumber(2), ]; // request  $response = $this-\u0026gt;put(\u0026#34;/products/{$product[\u0026#39;id\u0026#39;]}\u0026#34;, $product); $response-\u0026gt;assertStatus(200) -\u0026gt;assertJson([ \u0026#39;updated\u0026#39; =\u0026gt; true ]); // storage  $stored = Product::find($production[\u0026#39;id\u0026#39;]); $this-\u0026gt;assertEquals($product, $stored-\u0026gt;toArray()); } public function test_failing_product_details_update() { $product = [ \u0026#39;id\u0026#39; =\u0026gt; $fake-\u0026gt;uuid, \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, // cannot be empty  \u0026#39;description\u0026#39; =\u0026gt; $fake-\u0026gt;text, \u0026#39;price\u0026#39; =\u0026gt; $faker-\u0026gt;randomNumber(2), ]; $response = $this-\u0026gt;put(\u0026#34;/products/{$product[\u0026#39;id\u0026#39;]}\u0026#34;, $product); $response-\u0026gt;assertStatus(200) -\u0026gt;assertJson([ \u0026#39;updated\u0026#39; =\u0026gt; false, \u0026#39;error\u0026#39; =\u0026gt; [ \u0026#39;messages\u0026#39; =\u0026gt; [\u0026#39;title field is required.\u0026#39;], ], ]); // storage - ensure original title is still in place  $stored = Product::find($production[\u0026#39;id\u0026#39;]); $this-\u0026gt;assertEquals(\u0026#39;previous title\u0026#39;, $stored-\u0026gt;title); } } As far as functional testing goes, it is best to portray the usage of the feature from a broad perspective rather than digging into every detail of the steps of the function. Feature testing is usually considered to be the integration test between the units that make up the feature.\nMocking It is recommended with feature tests to only mock what\u0026rsquo;s external to your application to preserve the quality guarantee . Mocks are usually for 3rd-party APIs and other services that we integrate with, but not for internals such as storage.\nFor this example we will assume that this feature runs from a command line rather than over HTTP.\nThis example contains missing variables and is for illustrative purposes only.\n app/Features/UpdateFacebookPosts.php\nclass UpdateFacebookPosts extends Feature { public function handle() { $posts = $this-\u0026gt;run(FetchFacebookPostsJob::class); $this-\u0026gt;run(StoreFacebookPostsJob::class, [ \u0026#39;posts\u0026#39; =\u0026gt; $posts, ]); } } app/Domains/Facebook/Jobs/FetchFacebookPostsJob.php\nclass FetchFacebookPostsJob extends Job { public function handle(FacebookClient $fb) { return $fb-\u0026gt;posts(); } } tests/Features/UpdateFacebookPostsTest.php\nclass UpdateFacebookPostsTest extends TestCase { public function test_successfully_fetching_facebook_posts() { $mFB = Mockery::mock(FacebookClient::class); $mFB-\u0026gt;shouldReceive(\u0026#39;get\u0026#39;)-\u0026gt;with($args)-\u0026gt;andReturn($payload); $this-\u0026gt;app-\u0026gt;instance(FacebookClient::class, $mFB); $f = new UpdateFacebookPosts(); $result = $f-\u0026gt;handle(); // 0 in CLI means success!  $this-\u0026gt;assertEquals(0, $result); } } As shown in FetchFacebookPostsJob the client has been injected, so we had to replace the instance in IoC to load our mocked instance instead of the real one.\n FAQ What not to do in a feature?  Complex conditional logic: The feature passes output from Jobs and Operations but it barely knows anything about what goes on inside them. It only knows the sequence in which they should run and [maybe] some basic logic that is better be avoided and delegated to jobs and operations of possible. Process output from units: Parsing and transformation of content is best done in Job or an Operation. The output returned by a these units should always go as-is to the next unit. The feature doesn\u0026rsquo;t know much about the internals of steps or how they are actually performed. It is only aware of the sequence of the steps and the requirements of the different units through their signatures. This guarantees consistency and predictability when reading the feature\u0026rsquo;s code in the handle method and allows anyone new to the code to skim through quickly and have an idea about the required steps. Call another Feature: In order to avoid the Pyramid of Doom and reduce the cognitive load required to navigate the codebase and understand the code, Features should not call each other. Though the same feature may be called numerous times as long as it does not add up to the Feature\u0026rsquo;s complexity.   Should a Feature pass the entire set of input to other units? More elaborately: instead of specifying parameters in constructors, jobs and operations would accept an associative array of input and operate on that instead of a concise set of parameters.\nAnother option from\nFor several reasons:\n Clarity: Isolation: Reusability:   [Monolith] What to do about duplicate functionality between services? TL;DR It is recommended to have similar features across services than share features between them. Even if it meant repeating the same sequence of units.\n Since Monolith is all about separation of concerns per service, when dealing with multiple sides of the same application (e.g. Api, CMS, Web UI, etc.) we\u0026rsquo;d need to deal with their features differently; maybe not at the beginning but eventually we\u0026rsquo;ll find ourselves dealing with too many options and cramming a lot of confusing parameters in the same feature because we decided to share it with multiple services. To avoid all this, it is best to create a feature per service even if it means to repeat the same sequence of units. Below is a brief example to illustrate it.\nShared Feature\nSupposing that we decided to move the feature class from app/Services/{service}/Features to a place all services may access like app/Features/UpdateProductDetailsFeature.php and we\u0026rsquo;d like our Api and Web services to use it. This feature should serve the response in JSON when in the Api service and return a view when in Web:\nclass UpdateProductDetailsFeature { private $isApi; public function __construct(bool $isApi) { $this-\u0026gt;isApi = $isApi; } public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), ]); if ($this-\u0026gt;isApi) { return $this-\u0026gt;run(new RespondWithJsonJob($product)); } return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;product\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), ]); } }  This is yet a simple example but if we were to add more conditions to customize the experience further, we\u0026rsquo;d be throwing plenty of $this-\u0026gt;isApi everywhere in our feature. For example: the user reference from the API is a token, while the one from the Web is an ID retrieved from the session. Here\u0026rsquo;s how it would look like:\npublic function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); if ($this-\u0026gt;isApi) { $user = $this-\u0026gt;run(GetUserByApiTokenJob::class, [ \u0026#39;token\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;token\u0026#39;), ]); } else { $user = $this-\u0026gt;run(GetUserFromSessionJob::class); } $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;user\u0026#39; =\u0026gt; $user, ]); if ($this-\u0026gt;isApi) { return $this-\u0026gt;run(new RespondWithJsonJob($product)); } return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;product\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), ]); }  Ugly, isn\u0026rsquo;t it? See the other example for a cleaner approach below.\nFeature per Service\nApi::UpdateProductDetailsFeature\nlocated at app/Services/Api/Features/UpdateProductDetailsFeature.php\nclass UpdateProductDetailsFeature { public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); $user = $this-\u0026gt;run(GetUserFromSessionJob::class); $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;user\u0026#39; =\u0026gt; $user, ]); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;web.product.update\u0026#39;, ]); } }  Web::UpdateProductDetailsFeature\nlocated at app/Services/Web/Features/UpdateProductDetailsFeature.php\nclass UpdateProductDetailsFeature { public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDeatilsInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input() ]); $user = $this-\u0026gt;run(GetUserByApiTokenJob::class, [ \u0026#39;token\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;token\u0026#39;), ]); $product = $this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;user\u0026#39; =\u0026gt; $user, ]); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;view\u0026#39; =\u0026gt; \u0026#39;product\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;product\u0026#39;), ]); } }   "},{"uri":"https://docs.lucidarch.dev/jobs/","title":"Jobs","tags":[],"description":"","content":"Jobs do the actual work by implementing the business logic. Being the smallest unit in Lucid, a Job should do one thing, and one thing only - that is: perform a single task. They are the snippets of code we wish we had sometimes, and are pluggable to use anywhere in our application.\nOur objective with Jobs is to limit the scope of a single functionality so that we know where to look when finding it, and when we\u0026rsquo;re within its context we don\u0026rsquo;t tangle responsibility with other jobs to achieve the ultimate form of single responsibility principle.\nUsually called by a Feature or an Operation, but can be called from anywhere by any other class once setup as a custom dispatcher; hence, being the most shareable pieces of code.\nJobs in Domains Domains are where jobs live. It is how they\u0026rsquo;re organized in the folder structure, and represent the execution point of a single functionality within the corresponding domain. In other words, the only way to access a domain should be through a Job.\nHere\u0026rsquo;s an example of two domains (User \u0026amp; Product) exposing functionality through jobs.\n User [domain]  LoginUserJob LogoutUserJob UpdateUserProfileJob   Product [domain]  FindProductByIDJob SearchForProductJob SaveProductDetailsJob ValidateProductDetailsJob    Each of these is a class. Similar to other Lucid units it uses __constructor to define required parameters and is executed through the handle method when calling run.\nExample\nIn a Feature or Operation we can use $this-\u0026gt;run(ValidateProductDetailsJob::class) to run the job\u0026rsquo;s handle method.\napp/Domains/Product/ValidateProductDetailsJob\nuse Lucid\\Units\\Job; use App\\Domains\\Product\\ProductValidator; class ValidateProductDetailsJob extends Job { private array $input; public function __constructor(array $input) { $this-\u0026gt;input = $input; } /** * @param ProductValidator $validator * * @throws InvalidInputException */ public function handle(ProductValidator $validator) { $validator-\u0026gt;validate($this-\u0026gt;input); } } And in our feature: .../Features/AddProductFeature.php\nuse App\\Domains\\Http\\Jobs\\RespondWithJsonJob; use App\\Domains\\Product\\Jobs\\SaveProductDetailsJob; use App\\Domains\\Product\\Jobs\\ValidateProductDetailsJob; class AddProductFeature extends Feature { public function handle(Request $request) { $this-\u0026gt;run(ValidateProductDetailsJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input(), ]); $product = $this-\u0026gt;run(SaveProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), ]); return $this-\u0026gt;run(new RespondWithJsonJob($product)); } } Characteristics  Unlike other units (feature \u0026amp; operation), jobs don\u0026rsquo;t call other jobs to avoid obscure nested logic that end up being hard to follow and maintain. Jobs do not know about other units, they operate in isolation and are unaware of their surroundings. If they were people, they would\u0026rsquo;ve been called selfish for only being concerned with themselves and their needs to perform their task. Constructor parameters of a job - a.k.a. job signature - should be about the job itself only, not concerned with where it will be called from and in which conditions. Here\u0026rsquo;s a personification of a Job speaking: I, as a Job, in order to fulfill my task, I need \u0026ldquo;X\u0026rdquo; and \u0026ldquo;Y\u0026rdquo;, and once I am done I will return \u0026ldquo;Z\u0026rdquo; to you.\n   To validate your choice with jobs, simply ask yourself: \u0026ldquo;what does this job do?\u0026quot; and the answer should be \u0026ldquo;It [does this] then returns [that]\u0026quot; where:\n [does this]: should not include an \u0026ldquo;and\u0026rdquo; and should be made up of few words (single responsibility) [that]: ideally should either be an object, or a status response (boolean). TIP: Avoid returning associative arrays as much as possible, or at all if possible. They ramp up undefined structures and it will require more cognitive load over time to figure out their structures and values.\n   It is common practice to share jobs, in fact they are the units that are shared the most in code. For that reason we strive to make their code cover the entire spectrum of the task they perform, while careful not to end up having complex jobs just for the sake of reusing them.\nGood balance between complexity and functionality is key with jobs, it gets better with time and the more you familiarize yourself with Lucid!\nGenerate Job Class Use lucid CLI to generate a Job class that extends Lucid\u0026rsquo;s Job base class by default, which handle method is invoked when run by an Operation, Feature or a custom dispatcher.\nMicro Signature lucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue}\nExample\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Domains/Product/Tests/FindProductJobTest.php\nMonolith Signature lucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue}\nExample\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at app/Domains/Product/Tests/FindProductJobTest.php\n The generated Job class will automatically be suffixed with Job, so there\u0026rsquo;s no need for it to be specified in the command.\n¬†For more details on this command see the help manual with lucid make:job --help\n Calling Jobs Jobs are called using the run method that\u0026rsquo;s provided by extending one of Lucid\u0026rsquo;s runner units Feature \u0026amp; Operation classes, which internally relies on UnitDispatcher trait.\nSignature\nrun($job, $arguments = [], $extra = [])\n $job can be either a Job instance or the job\u0026rsquo;s class name (usually using SomeJob::class) [$arguments] is the associative array of arguments mapping the Job\u0026rsquo;s constructor parameters. Only used when $job is the class name and not the instance. [$extra] is for the Laravel dispatcher and is not used by Lucid for any purposes, passed straight to the dispatcher.  Dispatching Jobs \u0026amp; Arguments \nGiven this sample job that updates a product\u0026rsquo;s info in the database:\nnamespace App\\Domains\\Product\\Jobs; class UpdateProductDetailsJob extends Job { public function __construct(int $id, string $title, string $price, string $description) { $this-\u0026gt;id = $id $this-\u0026gt;title = $title $this-\u0026gt;price = $price $this-\u0026gt;description = $description } public function handle(): bool { $product = Product::find($this-\u0026gt;id); $product-\u0026gt;fill([ \u0026#39;title\u0026#39; =\u0026gt; $this-\u0026gt;title, \u0026#39;price\u0026#39; =\u0026gt; $this-\u0026gt;price, \u0026#39;description\u0026#39; =\u0026gt; $this-\u0026gt;description, ]); return $product-\u0026gt;save(); } } Calling this job from a feature or an operation is straight forward using run():\n$this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;id\u0026#39;), \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), ]); $arguments are sent as an associative array where the key should match parameters' names exactly, but not their order. Meaning that we could tangle parameter order, reducing the amount of change required when updating the job with new order of arguments or additional optional ones.\nThis would still work:\n$this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;id\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;id\u0026#39;), ]); Also, aesthetically allows to organize parameters by length which is nicer to look at!\n This is the recommended way of calling jobs, for it makes reading run statements in features and operations explicit and requires a reduced amount of knowledge, which preserves mental space for what actually matters.\n Dispatching Job Instances\nGiven this simple job that retrieves a user from the DB by their identifier:\nnamespace App\\Domains\\User\\Jobs; class GetUserJobID extends Job { private int $id; public function __construct(int $id) { $this-\u0026gt;id = $id; } public function handle() { return User::find($this-\u0026gt;id); } } We can simply initialize an instance and run it:\n$this-\u0026gt;run(new GetUserByIDJob($userId)); and it works exactly the same as if we did run(GetUserByIDJob::class, ['id' =\u0026gt; $userId]).\n¬†$arguments won\u0026rsquo;t apply when an initialized job is run.\n Since the job requires only one argument, and looking at the run line is intuitively indicative of the intended functionality and the argument, we can simply initialize the job ourselves and pass it to the dispatcher.\nThis is familiar with jobs that are known to (almost) never need to evolve beyond their initial functionality, and is surely not recommended when the job requires two or more parameters because of the extra effort required to figure out the parameters when reading run statements.\nTake for the example the case of a job with more parameters:\n$this-\u0026gt;run(new UpdateProductDetailsJob($id, $title, $description, $price)) instead of this:\n$this-\u0026gt;run(UpdateProductDetailsJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $id, \u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description, \u0026#39;price\u0026#39; =\u0026gt; $price, ]) Choosing Between Initialization \u0026amp; Separate Arguments\nAs mentioned above, it is recommended to always call with arguments separately instead of initializing jobs externally, because it makes code easier to read when there are multiple jobs in a sequence.\nHere\u0026rsquo;s a comparison of the two approaches in the following handle method, could be for a feature or an operation:\nSeparate: A bit more writing but clearer when reading.\npublic function handle(Request $request) { $this-\u0026gt;run(ValidateProductInputJob::class, [ \u0026#39;input\u0026#39; =\u0026gt; $request-\u0026gt;input(), ]); $photos = $this-\u0026gt;run(UploadProductPicturesJob::class, [ \u0026#39;cover\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;pictures.cover\u0026#39;), \u0026#39;showcase\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;pictures.showcase\u0026#39;), ]); $product = $this-\u0026gt;run(CreateProductJob::class, [ \u0026#39;title\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;title\u0026#39;), \u0026#39;price\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;price\u0026#39;), \u0026#39;description\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;description\u0026#39;), \u0026#39;provider\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;provider\u0026#39;), \u0026#39;photos\u0026#39; =\u0026gt; $photos ]); $isStockUpdated = $this-\u0026gt;run(UpdateProductStockAvailabilityJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $product-\u0026gt;id, \u0026#39;available_count\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;available_count\u0026#39;), ]); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;data\u0026#39; =\u0026gt; $product, \u0026#39;template\u0026#39; =\u0026gt; \u0026#39;product.update\u0026#39;, ]); } Initialized: Fast to write but harder to read.\npublic function handle(Request $request) { $this-\u0026gt;run(new ValidateProductInputJob($request-\u0026gt;input)); $photos = $this-\u0026gt;run(new UploadProductPicturesJob( $request-\u0026gt;input(\u0026#39;pictures.cover\u0026#39;), $request-\u0026gt;input(\u0026#39;pictures.showcase\u0026#39;)) ); $product = $this-\u0026gt;run(new CreateProductJob( $request-\u0026gt;input(\u0026#39;title\u0026#39;), $request-\u0026gt;input(\u0026#39;price\u0026#39;), $request-\u0026gt;input(\u0026#39;description\u0026#39;), $request-\u0026gt;input(\u0026#39;provider\u0026#39;), $photos) ); $isStockUpdated = $this-\u0026gt;run(new UpdateProductStockAvailabilityJob( $product-\u0026gt;id, $request-\u0026gt;input(\u0026#39;available_count\u0026#39;)); } Queuable Jobs You may turn any job into a queueable job that will be dispatched using Laravel Queues rather than running synchronously, by simply implementing ShouldQueue interface.\nGenerate Queueable Job lucid make:job UploadPhotos files --queue Will produce the following job class:\nclass UploadPhotosJob extends Job implements ShouldQueue { public function handle() { // photo uploads will be processed in the queue  } } This job will be treated exactly as Laravel treats queued jobs.\nSpecify Queue Name public function __construct() { /* * set the name of the queue on which to dispatch this job. * if using Horizon, this should be the same as the one configured there. */ $this-\u0026gt;onQueue(\u0026#39;emails\u0026#39;); } Custom Dispatcher You may turn any class in your application into a job dispatcher. To equip a class for running jobs use Lucid\\Bus\\UnitDispatcher trait.\nuse Lucid\\Bus\\UnitDispatcher; class Handler extends ExceptionHandler { use UnitDispatcher; public function custom() { return $this-\u0026gt;run(TheJob::class); } } Handling Errors with Jobs It is common to want to dispatch jobs from Exceptions\\Handler, where you may want to centralize your error responses in jobs to maintain a consistent structure across your application.\nAssuming that we are working on an API where all our errors must be returned in JSON format, to avoid the accidental rendering of an HTML page leading to unexpected behaviours. We would create a job to be run when encountering an exception that includes the response structure. Lucid ships with one that can be used as default, available in the built-in Http domain App\\Domains\\Http\\Jobs\\RespondWithJsonErrorJob which has a simple signature:\n$this-\u0026gt;run(RespondWithJobErrorJob::class, [ \u0026#39;message\u0026#39; =\u0026gt; $e-\u0026gt;getMessage(), \u0026#39;code\u0026#39; =\u0026gt; 2900, // custom error code, optional, default: 400  \u0026#39;status\u0026#39; =\u0026gt; 400, // HTTP response status code, optional, default: 400  \u0026#39;headers\u0026#39; =\u0026gt; [], // customize headers  \u0026#39;options\u0026#39; =\u0026gt; 0, // will be passed to ResponseFactory::json() ]); Running this job in response to our exceptions will guarantee that the consumer always receives a consistent JSON structure:\n{ \u0026#34;status\u0026#34;: 400, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: 2900, \u0026#34;message\u0026#34;: \u0026#34;Expressive message about the error.\u0026#34; } } Rendering Exceptions In our Handler class we can register a custom rendering Closure for exceptions of a given type and use the job to render JSON.\nuse App\\Exceptions\\CustomException; /** * Register the exception handling callbacks for the application. * * @return void */ public function register() { $this-\u0026gt;renderable(function (CustomException $e, $request) { return $this-\u0026gt;run(RespondWithJsonErrorJob::class, [ \u0026#39;status\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; $e-\u0026gt;getMessage(), ]); }); } You may also wish to return a view in the case of an HTML response instead:\nuse App\\Exceptions\\CustomException; /** * Register the exception handling callbacks for the application. * * @return void */ public function register() { $this-\u0026gt;renderable(function (CustomException $e, $request) { return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;status\u0026#39; =\u0026gt; 500, \u0026#39;template\u0026#39; =\u0026gt; \u0026#39;errors.custom\u0026#39;, ]); }); } Reportable \u0026amp; Renderable Exceptions Similar to our Handler class, we may have our exceptions render themselves by defining render method in the exception class.\nnamespace App\\Exceptions; use Exception; use Lucid\\Bus\\UnitDispatcher; class RenderException extends Exception { use UnitDispatcher; /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function render($request) { return $this-\u0026gt;run(RespondWithJsonErrorJob::class, [ \u0026#39;status\u0026#39; =\u0026gt; 500, \u0026#39;message\u0026#39; =\u0026gt; $this-\u0026gt;getMessage(), ]); } } Testing When generating a job with lucid make:job a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nTheir locations help us encapsulate our domains since they would contain all they need to operate in isolation.\nMicro lucid make:job UpdateProductDetails product Would generate two files:\n app/Domains/Product/Jobs/UpdateProductDetailsJob app/Domains/Product/Tests/Jobs/UpdateProductDetailsJobTest  Monolith lucid make:job UpdateProductDetails product Would generate two files:\n app/Domains/Product/Jobs/UpdateProductDetailsJob app/Domains/Product/Tests/Jobs/UpdateProductDetailsJobTest   The example below illustrates a simplified version of testing user input validation job:\nnamespace App\\Domains\\User\\Tests\\Jobs; use Tests\\TestCase; use Lucid\\Exceptions\\InvalidInputException; use App\\Domains\\User\\Jobs\\ValidateUserProfileInputJob; class ValidateUserProfileInputJobTest extends TestCase { public function test_passes_validation() { $data = [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;john@example.com\u0026#39;, \u0026#39;occupation\u0026#39; =\u0026gt; \u0026#39;Fun Seeker\u0026#39;, ]; $job = new ValidateUserProfileInputJob($data); $isValid = $job-\u0026gt;handle(); $this-\u0026gt;assertTrue($isValid); } public function test_fails_with_empty_name() { $this-\u0026gt;expectException(InvalidInputException::class); $this-\u0026gt;expectExceptionMessage(\u0026#39;The name field is required.\u0026#39;); $invalid = [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;john@example.com\u0026#39;, \u0026#39;occupation\u0026#39; =\u0026gt; \u0026#39;Fun Seeker\u0026#39;, ]; $job = new ValidateUserProfileInputJob($invalid); $job-\u0026gt;handle(); } } Mocking In most cases you wouldn\u0026rsquo;t want to mock with jobs because they are the actual units of work that need to be tested, though there would still be cases where you must mock. E.g. fetching content from an external source as illustrated in the example below, where we have a job to fetch articles from dev.to to test.\nOur job looks like this:\nnamespace App\\Domains\\DevTo\\Jobs; use Lucid\\Units\\Job; use App\\Domains\\DevTo\\Client; use Illuminate\\Support\\Collection; class FetchDevToArticlesJob extends Job { public function handle(Client $devto): Collection { $articles = $devto-\u0026gt;articles(); return collect($articles); } } Client class code has been omitted, needless to say it is where the connection to dev.to happens to retrieve the articles:\nTest\nnamespace App\\Domains\\DevTo\\Tests\\Jobs; use Mockery; use Tests\\TestCase; use App\\Domains\\DevTo\\Client; use Illuminate\\Support\\Collection; use App\\Domains\\DevTo\\Jobs\\FetchDevToArticlesJob; class FetchDevToArticlesJobTest extends TestCase { public function test_fetch_dev_to_articles_job() { $expected = json_encode([ \u0026#39;expected\u0026#39; =\u0026gt; \u0026#39;response\u0026#39;, \u0026#39;goes\u0026#39; =\u0026gt; \u0026#39;here\u0026#39;, ], true); // mock client  $mClient = Mockery::mock(Client::class); $mClient-\u0026gt;shouldReceive(\u0026#39;articles\u0026#39;)-\u0026gt;withNoArgs()-\u0026gt;andReturn($expected); $job = new FetchDevToArticlesJob(); // execute job with injected mocked client  $articles = $job-\u0026gt;handle($mClient); $this-\u0026gt;assertInstanceOf(Collection::class, $articles); } } "},{"uri":"https://docs.lucidarch.dev/operations/","title":"Operations","tags":[],"description":"","content":"Their purpose is to increase the degree of code reusability by piecing jobs together to provide composite functionalities from across domains.\n Operations are a group of jobs that deliver multi-step functionalities. Technically, Operation classes are similar to Feature classes in usage; meaning that they both have run($job,$params) in common to run jobs from any domain, and can be called standalone (e.g. call an operation from a Command).\nHowever, conceptually they have their differences in that a Feature can run multiple Operation and Job classes while an Operation can run multiple Jobs only. They also differ in what they represent to the application: A feature is what the application provides to the outside, while an operation is more of an internal aspect. Technically they differ in they way they are dispatched, where we serve a feature but we run an operation; any class can do so the same as a Feature class would by turning it into a dispatcher class.\nExample\nGiven that we are working on a publishing platform, and upon creating an article we would like to send notifications to the subscribers of the author, here\u0026rsquo;s what that operation may look like:\nclass NotifySubscribersOperation extends Operation { private int $authorId; public function __construct(int $authorId) { $this-\u0026gt;authorId = $authorId; } /** * Sends notifications to subscribers. * * @return int Number of notification jobs enqueued. */ public function handle(): int { $author = $this-\u0026gt;run(GetAuthorByIDJob::class, [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;authorId, ]); do { $result = $this-\u0026gt;run(PaginateSubscribersJob::class, [ \u0026#39;authorId\u0026#39; =\u0026gt; $this-\u0026gt;authorId, ]); if ($result-\u0026gt;subscribers-\u0026gt;isNotEmpty()) { // it\u0026#39;s a queueable job so it will be enqueued, no waiting time  $this-\u0026gt;run(SendNotificationJob::class, [ \u0026#39;from\u0026#39; =\u0026gt; $author, \u0026#39;to\u0026#39; =\u0026gt; $result-\u0026gt;subscribers, \u0026#39;notification\u0026#39; =\u0026gt; \u0026#39;article.published\u0026#39;, ]); } } while ($result-\u0026gt;hasMorePages()); return $result-\u0026gt;total; } } As you see the jobs that are used in this operation are ones that can be shared with other areas in our code as well, increasing the degree of reusable code.\n  GetAuthorByIDJob: to retrieve a user/author by ID is as abstract as it can get, and will definitely be used numerous times in our application.\n  PaginateSubscribersJob: would be used every time we need to retrieve an author\u0026rsquo;s subscribers. Such jobs usually grow in responsibility over time and their results become more customizable.\nExample: later it may allow to specify a certain limit to the number of subscribers to return, then we\u0026rsquo;d be able to paginate them for listing subscribers in a view or over an API.\n  SendNotificationJob: will be used every time we need to send a notification, regardless of the type of notification to be sent since it is specified with the notification parameter. Which also can grow into providing more customization such as specifying the type of notification to send (e.g. mobile, browser, web, email etc.).\n  With this we\u0026rsquo;ve achieved single responsibility at a low cost of debt and prepared for scale. In fact, some of these jobs would\u0026rsquo;ve been implemented already by the time we reached this operation which makes it quick to biuld.\nNow we have that functionality bundled at our disposal to be called whenever needed:\n$this-\u0026gt;run(NotifySubscribersOperation::class, [ \u0026#39;authorId\u0026#39; =\u0026gt; $authorId, ]); Generate Operation Class Use lucid CLI to generate an Operation class that extends Lucid\u0026rsquo;s Operation base class by default, which handle method is invoked when run by a Feature or a custom dispatcher.\nMicro Signature lucid make:operation \u0026lt;operation\u0026gt; {--Q|queue}\nExample\nlucid make:operation NotifySubscribers Generated class will be at app/Operations/NotifySubscribersOperation.php\nand its test at tests/Operations/NotifySubscribersOperationTest.php\nMonolith Signature lucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt; {--Q|queue}\nExample\nlucid make:operation NotifySubscribers publishing Generated class will be at app/Services/Publishing/Operations/NotifySubscribersOperation.php\nand its test at app/Services/Publishing/Tests/Operations/NotifySubscribersOperationTest.php\n The generated Operation class will automatically be suffixed with Operation, so there\u0026rsquo;s no need for it to be specified in the command.\nCalling Operations Similar to jobs, and Operation can also be called using the run method that\u0026rsquo;s provided by extending one Lucid\u0026rsquo;s Feature or a custom dispatcher,\nSee here for more on the run method.\nclass PublishArticleFeature extends Feature { $this-\u0026gt;run(new ValidateArticlePublishingInputJob($request-\u0026gt;input())); $this-\u0026gt;run(SetArticlePublishingRulesOperation::class, [ \u0026#39;id\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;id\u0026#39;), \u0026#39;schedule\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;datetime\u0026#39;), \u0026#39;platforms\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;platforms\u0026#39;), \u0026#39;visibility\u0026#39; =\u0026gt; $request-\u0026gt;input(\u0026#39;visibility\u0026#39;), ]); $this-\u0026gt;run(NotifySubscribersOperation::class, [ \u0026#39;authorId\u0026#39; =\u0026gt; Auth::id(), ]); $article = $this-\u0026gt;run(new GetArticleByIDJob($request-\u0026gt;input(\u0026#39;id\u0026#39;))); return $this-\u0026gt;run(RespondWithViewJob::class, [ \u0026#39;data\u0026#39; =\u0026gt; compact(\u0026#39;article\u0026#39;), \u0026#39;template\u0026#39; =\u0026gt; \u0026#39;articles.publish.success\u0026#39;, ]); } Queueable Operations You may turn any operation into a queueable operation that will be dispatched using Laravel Queues rather than running synchronously, by simply implementing ShouldQueue interface.\nGenerate Queueable Operation Use the --queue or shorthand -Q to generate a queueable operation.\nlucid make:job NotifySubscribers --queue Will produce the following operation class:\nclass NotifySubscribersOperation extends Operation implements ShouldQueue { public function handle() { // notifications processing will happen in the queue  } } This job will be treated exactly as Laravel treats queued jobs.\nSpecify Queue Name public function __construct() { /* * set the name of the queue on which to dispatch this operation. * if using Horizon, this should be the same as the one configured there. */ $this-\u0026gt;onQueue(\u0026#39;notifications\u0026#39;); } Testing When generating an operation with lucid make:operation a test class is automatically generated along, having markIncomplete() statement in a stub method as a reminder to fill the missing test.\nMicro lucid make:operation NotifySubscribers Would generate two files:\n app/Operations/NotifySubscribersOperation.php tests/Operations/NotifySubscribersOperationTest.php  Monolith lucid make:operation NotifySubscribers publishing Would generate two files:\n app/Services/Publishing/Operations/NotifySubscribersOperation.php app/Services/Publishing/Tests/Operations/NotifySubscribersOperationTest.php   The purpose of operation testing is to ensure that the integration between the jobs it runs is working as expected, but we do not have to test every job\u0026rsquo;s case on its own, for that we rely on jobs being tested for their integrity.\nFor example, consider the following operation test:\n\u0026lt;?php namespace App\\Services\\Publishing\\Tests\\Operations; use Tests\\TestCase; use App\\Data\\Models\\Author; use App\\Data\\Models\\Subscriber; use Illuminate\\Support\\Facades\\Queue; use App\\Services\\Operations\\NotifySubscribersOperation; class NotifySubscribersOperationTest extends TestCase { public function test_successfully_notifying_subscribers() { // SendNotificationJob will be dispatched to the queue  Queue::fake(); // queue must be empty  Queue::assertNothingPushed(); // n. of subscribers we\u0026#39;re testing with  $subscribers = 10; $author = Author::factory() -\u0026gt;has(Subscriber::factory($subscribers)); -\u0026gt;create(); $op = new NotifySubscribersOperation($author-\u0026gt;id); $result = $op-\u0026gt;handle(); // assert all subscribers were paginated  $this-\u0026gt;assertEquals($subscribers, $result); // assert the correct n. of SendNotificationJob were dispatched  Queue::assertPushed(SendNotificationJob::class, $subscribers); } } Mocking Jobs When testing, you may occasionally need to skip dispatching a certain job but would still want to make sure that the operation actually ran the job as expected, with the correct parameters. In such cases we would mock the operation\u0026rsquo;s run partially.\nIn our case we\u0026rsquo;d update our test to not dispatch SendNotificationJob so that we don\u0026rsquo;t actually send notifications. This may seem odd at first because we are mocking the class that we are actually testing, but with partial mocks only the methods that we set expectations on would be mocked and the rest would be dispatched. And in case the operation doesn\u0026rsquo;t call run(SendNotificationJob::class, $params) with the expected parameters the test will fail.\n\u0026lt;?php namespace App\\Services\\Publishing\\Tests\\Operations; use Mockery; use App\\Data\\Models\\Author; use App\\Data\\Models\\Subscriber; use App\\Services\\Operations\\NotifySubscribersOperation; class NotifySubscribersOperationTest extends TestCase { public function test_successfully_notifying_subscribers_with_mock() { // n. of subscribers we\u0026#39;re testing with  $subscribers = 10; $author = Author::factory() -\u0026gt;has(Subscriber::factory($subscribers)); -\u0026gt;create(); // create operation mock instance  $mOp = Mockery::mock(NotifySubscribersOperation::class, [$author-\u0026gt;id]); // set expectations to jobs that need to be skipped  $mOp-\u0026gt;shouldReceive(\u0026#39;run\u0026#39;) -\u0026gt;with(SendNotificationJob::class, [ \u0026#39;from\u0026#39; =\u0026gt; $author, \u0026#39;to\u0026#39; =\u0026gt; $author-\u0026gt;subscribers, \u0026#39;notification\u0026#39; =\u0026gt; \u0026#39;article.published\u0026#39;, ]); $result = $mOp-\u0026gt;handle(); // assert all subscribers were paginated  $this-\u0026gt;assertEquals($subscribers, $result); } } Whether to mock or not is a case-by-case decision, but as a general guideline it is best to always test with what\u0026rsquo;s closest to reality.\n"},{"uri":"https://docs.lucidarch.dev/services/","title":"Services","tags":[],"description":"","content":"Are the differentiating factors of Monolith. Their presence is necessary in multi-purpose projects that are set to scale in several areas of functionalities, a.k.a horizonal growth. They communicate with domains to compose jobs into groups of functionalities in their own features and operations.\nStructure Services are structured for scale, by adding an encapsulation layer for features, operations, routes, controllers, commands, resources (views) providers, tests and database; allowing our application to contain sections that differ in high degree and have plenty of those without causing clutter yet keep code navigation straight-forward.\nThe example below illustrates a comparison between a Lucid Monolith and a traditional directory separation in an application that has Chat, Product Management, Forum, Api and Admin listed with their features below:\n Chat  Send message Update message Delete message Share message Connect to channel Search messages   Forum  CRUD questions Manage questions in categories Schedule newsletter update Set answer as accepted Promote user as member Follow/unfollow question Search questions SEO      Product Management  CRUD product Add product to category Update product price Update product availability Search products   Admin  CRUD users CRUD organizations CRUD products CRUD projects   Api  CRUD application (like Slack \u0026amp; Facebook apps etc.) Send message Subscribe to product updates Subscribe to question updates      An application this large will easily grow in files and directories to unmaintainable extents. To avoid that, we\u0026rsquo;ll create services for each to hold all their needs to function, which is exactly what\u0026rsquo;s initially in Laravel\u0026rsquo;s /app directory, in addition to tests.\n app/Services/Chat ‚îú‚îÄ‚îÄ Console ‚îÇ¬†‚îî‚îÄ‚îÄ Commands ‚îú‚îÄ‚îÄ Features ‚îú‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ Http ‚îÇ¬†‚îú‚îÄ‚îÄ Controllers ‚îÇ¬†‚îî‚îÄ‚îÄ Middleware ‚îú‚îÄ‚îÄ Providers ‚îÇ¬†‚îú‚îÄ‚îÄ ApiServiceProvider.php ‚îÇ¬†‚îú‚îÄ‚îÄ BroadcastServiceProvider.php ‚îÇ¬†‚îî‚îÄ‚îÄ RouteServiceProvider.php ‚îú‚îÄ‚îÄ Tests ‚îÇ¬†‚îî‚îÄ‚îÄ Features ‚îÇ¬†‚îî‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ database ‚îÇ¬†‚îú‚îÄ‚îÄ factories ‚îÇ¬†‚îú‚îÄ‚îÄ migrations ‚îÇ¬†‚îî‚îÄ‚îÄ seeds ‚îú‚îÄ‚îÄ resources ‚îÇ¬†‚îú‚îÄ‚îÄ lang ‚îÇ¬†‚îî‚îÄ‚îÄ views ‚îî‚îÄ‚îÄ routes ‚îú‚îÄ‚îÄ api.php ‚îú‚îÄ‚îÄ channels.php ‚îú‚îÄ‚îÄ console.php ‚îî‚îÄ‚îÄ web.php  ¬†This is the initial structure of a service, however you may choose to customise it for what it needs only, for example if you prefer to have the database stuff at the root or that this service doesn\u0026rsquo;t have any database work to do on its own, you would simply remove it from within the service. Similar for Console and everything else.\n  Here\u0026rsquo;s an illustrative comparison between the traditional and the services approaches in routing and controllers:\nRoutes Showcase Traditional\nUsing the traditional approach where all of our routes are in routes/web.php, we\u0026rsquo;ll find that this file will keep growing the more functionalities we add. Also, if more than a single person is working on it, it is highly likely to produce conflicts on merge which is always an unpleasant experience.\n Expand file locations to see their code.\n  routes/web.php       routes/api.php      Of course there are ways to separate routes into several files and load them in the service provider, but routing isn\u0026rsquo;t the only problem that we will be facing, it is just a part of it.\nLucid Service Routes Showcase\nOn the other hand, with services we\u0026rsquo;ve separated these routes files where they belong to have a pleasant experience working with them and avoid conflicts as a team.\n app/Services/Chat/routes/web.php  Route::middleware([\u0026#39;auth\u0026#39;, \u0026#39;subscription\u0026#39;])-\u0026gt;group(\u0026#39;chat\u0026#39;, function() { Route::post(\u0026#39;/messages\u0026#39;, [ChatController::class, \u0026#39;sendMessage\u0026#39;]); Route::put(\u0026#39;/messages/{id}\u0026#39;, [ChatController::class, \u0026#39;updateMessage\u0026#39;]); Route::post(\u0026#39;/messages/{id}/share\u0026#39;, [ChatController::class, \u0026#39;shareMessage\u0026#39;]); Route::post(\u0026#39;/channels/{channel}/connect\u0026#39;, [ChatController::class, \u0026#39;connect\u0026#39;]); Route::post(\u0026#39;/search\u0026#39;, [ChatController::class, \u0026#39;search\u0026#39;]); });     app/Services/Forum/routes/web.php  Route::middleware([\u0026#39;auth\u0026#39;, \u0026#39;subscription\u0026#39;])-\u0026gt;group(\u0026#39;forum\u0026#39;, function() { Route::get(\u0026#39;/questions\u0026#39;, [ForumController::class, \u0026#39;questions\u0026#39;]); Route::post(\u0026#39;/questions\u0026#39;, [ForumController::class, \u0026#39;addQuestion\u0026#39;]); Route::put(\u0026#39;/questions/{id}\u0026#39;, [ForumController::class, \u0026#39;updateQuestion\u0026#39;]); Route::delete(\u0026#39;/questions/{id}\u0026#39;, [ForumController::class, \u0026#39;deleteQuestion\u0026#39;]); Route::put(\u0026#39;/questions/{id}/category\u0026#39;, [ForumController::class, \u0026#39;category\u0026#39;]); Route::put(\u0026#39;/questions/{id}/accept\u0026#39;, [ForumController::class, \u0026#39;accept\u0026#39;]); Route::post(\u0026#39;/questions/{id}/follow\u0026#39;, [ForumUserController::class, \u0026#39;follow\u0026#39;]); Route::get(\u0026#39;/questions/search\u0026#39;, [ForumUserController::class, \u0026#39;search\u0026#39;]); Route::put(\u0026#39;/users/{id}/promote\u0026#39;, [ForumUserController::class, \u0026#39;promote\u0026#39;]); });     app/Services/Products/routes/web.php  Route::middleware([\u0026#39;auth\u0026#39;, \u0026#39;subscription\u0026#39;])-\u0026gt;group(\u0026#39;products\u0026#39;, function() { Route::get(\u0026#39;/search\u0026#39;, [ProductController::class, \u0026#39;search\u0026#39;]); Route::get(\u0026#39;/\u0026#39;, [ProductController::class, \u0026#39;get\u0026#39;]); Route::get(\u0026#39;/{id}\u0026#39;, [ProductController::class, \u0026#39;show\u0026#39;]); Route::post(\u0026#39;/\u0026#39;, [ProductController::class, \u0026#39;add\u0026#39;]); Route::put(\u0026#39;/{id}\u0026#39;, [ProductController::class, \u0026#39;update\u0026#39;]); Route::delete(\u0026#39;/{id}\u0026#39;, [ProductController::class, \u0026#39;delete\u0026#39;]); Route::put(\u0026#39;/{id}/category\u0026#39;, [ProductController::class, \u0026#39;category\u0026#39;]); Route::put(\u0026#39;/{id}/price\u0026#39;, [ProductController::class, \u0026#39;price\u0026#39;]); Route::put(\u0026#39;/{id}/stock\u0026#39;, [ProductController::class, \u0026#39;stock\u0026#39;]); });     app/Services/Api/routes/api.php  Route::middleware([\u0026#39;throttle:api\u0026#39;])-\u0026gt;group(\u0026#39;api\u0026#39;, function () { Route::get(\u0026#39;/apps/search\u0026#39;, [AppController::class, \u0026#39;search\u0026#39;]); Route::get(\u0026#39;/apps\u0026#39;, [AppController::class, \u0026#39;get\u0026#39;]); Route::get(\u0026#39;/apps/{id}\u0026#39;, [AppController::class, \u0026#39;show\u0026#39;]); Route::post(\u0026#39;/apps\u0026#39;, [AppController::class, \u0026#39;add\u0026#39;]); Route::put(\u0026#39;/apps/{id}\u0026#39;, [AppController::class, \u0026#39;update\u0026#39;]); Route::delete(\u0026#39;/apps/{id}\u0026#39;, [AppController::class, \u0026#39;delete\u0026#39;]); Route::post(\u0026#39;/channels/{id}\u0026#39;, [ChatController::class, \u0026#39;subscribe\u0026#39;]); Route::post(\u0026#39;/products/{id}\u0026#39;, [ProductController::class, \u0026#39;subscribe\u0026#39;]); Route::post(\u0026#39;/questions/{id}\u0026#39;, [ForumController::class, \u0026#39;subscribe\u0026#39;]); });     app/Services/Admin/routes/web.php      Another variation of routes would be to reduce Admin routes by including them in their corresponding services instead of having Admin service include them all. Both approaches have their benefits so you may choose whichever works best for your case.\n app/Services/Products/routes/web.php       Controllers Showcase Consolidating routes and controllers in services allows us to have them side-by-side within the same context, so that we don\u0026rsquo;t have to go digging for code in foreign directories.\nTraditional\n app/Http/Controllers ‚îú‚îÄ‚îÄ Admin ‚îÇ¬†‚îú‚îÄ‚îÄ ProductController.php ‚îÇ¬†‚îú‚îÄ‚îÄ ForumController.php ‚îÇ¬†‚îú‚îÄ‚îÄ UserController.php ‚îÇ¬†‚îî‚îÄ‚îÄ OrganizationController.php ‚îú‚îÄ‚îÄ Api ‚îÇ¬†‚îú‚îÄ‚îÄ AppController.php ‚îÇ¬†‚îú‚îÄ‚îÄ ChatController.php ‚îÇ¬†‚îî‚îÄ‚îÄ HookController.php ‚îú‚îÄ‚îÄ Chat ‚îÇ¬†‚îî‚îÄ‚îÄ MessageController.php ‚îú‚îÄ‚îÄ Products ‚îÇ¬†‚îî‚îÄ‚îÄ ProductController.php ‚îî‚îÄ‚îÄ Forum ‚îú‚îÄ‚îÄ QuestionController.php ‚îú‚îÄ‚îÄ CategoryController.php ‚îî‚îÄ‚îÄ MemberController.php   Lucid Service Controllers\n app/Services/Admin/Http/Controllers ‚îú‚îÄ‚îÄ ProductController.php ‚îú‚îÄ‚îÄ ForumController.php ‚îú‚îÄ‚îÄ UserController.php ‚îî‚îÄ‚îÄ OrganizationController.php app/Services/Api/Http/Controllers ‚îú‚îÄ‚îÄ AppController.php ‚îú‚îÄ‚îÄ ChatController.php ‚îî‚îÄ‚îÄ HookController.php app/Services/Chat/Http/Controllers ‚îî‚îÄ‚îÄ MessageController.php app/Services/ProductManagement/Http/Controllers ‚îî‚îÄ‚îÄ ProductController.php app/Services/Forum/Http/Controllers ‚îú‚îÄ‚îÄ QuestionController.php ‚îú‚îÄ‚îÄ MemberController.php ‚îî‚îÄ‚îÄ CategoryController.php     Benefits Concentration Working on a feature in a service wouldn\u0026rsquo;t concern you with others outside the bounds of said service.\n  Efficiency Reduced code review time and merge conflicts when working with a team, due to the separation of concerns.\n  Separation Consider having Single Responsibility and Separation of Concerns, not only at the code level, but also in the structure.\n   ¬†Remember that it is completely optional to use Services. In fact there is no obligation whatsoever with Lucid, pick any unit from the stack and use it to your convenience; just preserve Lucid\u0026rsquo;s guidelines as you do.\n Create a Service lucid make:service Chat This will generate the directory structure for a service in app/Services/Chat/*\n app/Services/Chat ‚îú‚îÄ‚îÄ Console ‚îÇ¬†‚îî‚îÄ‚îÄ Commands ‚îú‚îÄ‚îÄ Features ‚îú‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ Http ‚îÇ¬†‚îú‚îÄ‚îÄ Controllers ‚îÇ¬†‚îî‚îÄ‚îÄ Middleware ‚îú‚îÄ‚îÄ Providers ‚îÇ¬†‚îú‚îÄ‚îÄ ApiServiceProvider.php ‚îÇ¬†‚îú‚îÄ‚îÄ BroadcastServiceProvider.php ‚îÇ¬†‚îî‚îÄ‚îÄ RouteServiceProvider.php ‚îú‚îÄ‚îÄ Tests ‚îÇ¬†‚îî‚îÄ‚îÄ Features ‚îÇ¬†‚îî‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ database ‚îÇ¬†‚îú‚îÄ‚îÄ factories ‚îÇ¬†‚îú‚îÄ‚îÄ migrations ‚îÇ¬†‚îî‚îÄ‚îÄ seeds ‚îú‚îÄ‚îÄ resources ‚îÇ¬†‚îú‚îÄ‚îÄ lang ‚îÇ¬†‚îî‚îÄ‚îÄ views ‚îî‚îÄ‚îÄ routes ‚îú‚îÄ‚îÄ api.php ‚îú‚îÄ‚îÄ channels.php ‚îú‚îÄ‚îÄ console.php ‚îî‚îÄ‚îÄ web.php  Register Service Once created we\u0026rsquo;ll need to tell Laravel about our service so that it loads its files such as routes, migrations, views and others. There are two ways to register the service\u0026rsquo;s provider, in this case it\u0026rsquo;s ChatServiceProvider:\n1. In Configuration: config/app.php\nAdd App\\Services\\Chat\\Providers\\ChatServiceProvider::class to 'providers' in config/app.php\nThis will register and load the service every time the application launches.\n2. In AppServiceProvider::register\n\u0026lt;?php namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use App\\Services\\Api\\Providers\\ApiServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Register any application services. * * @return void */ public function register() { $this-\u0026gt;app-\u0026gt;register(ApiServiceProvider::class); } } This opens up possibilities for conditional registration of services. For example you may choose to load Dashboard service only when in the local environment:\npublic function register() { if (App::environment(\u0026#39;local\u0026#39;)) { $this-\u0026gt;app-\u0026gt;register(DashboardServiceProvider::class); } } Run Service Tests Initially service tests aren\u0026rsquo;t automatically registered in phpunit.xml to run by default when running phpunit. To do that, please add the following to your phpunit.xml under \u0026lt;testsuites\u0026gt; (must be done for each service), which also allows running the service\u0026rsquo;s testsuite in isolation with phpunit --testsuite \u0026lt;name\u0026gt;\n\u0026lt;testsuite name=\u0026#34;Chat\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./app/Services/Chat/Tests\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; Now we can run the tests for this service in isolation:\nphpunit --testsuite Chat Working with Services All unit generation commands (lucid make:*) have an optional parameter \u0026lt;service\u0026gt; to specify which service you\u0026rsquo;d like to generate the unit into.\n¬†command parameters are case-insensitive, Lucid will try to convert to the corresponding case.\n Controllers Signature lucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:controller message chat Will generate app/Services/Chat/Http/Controllers/MessageController.php\n\u0026lt;?php namespace App\\Services\\Chat\\Http\\Controllers; use Lucid\\Units\\Controller; class MessageController extends Controller { } Features Signature lucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:feature SendMessage chat Will generate app/Services/Chat/Features/SendMessageFeature.php\n\u0026lt;?php namespace App\\Services\\Chat\\Features; use Lucid\\Units\\Feature; use Illuminate\\Http\\Request; class SendMessageFeature extends Feature { public function handle(Request $request) { } } Operations Signature lucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:operation EnqueueMessageForSending chat Will generate app/Services/Chat/Operations/EnqueueMessageForSendingOperation.php\n\u0026lt;?php namespace App\\Services\\Chat\\Operations; use Lucid\\Units\\Operation; class EnqueueMessageForSendingOperation extends Operation { /** * Create a new operation instance. * * @return void */ public function __construct() { //  } /** * Execute the operation. * * @return void */ public function handle() { } } Migrations When generated, migrations are automatically registered in the global application\u0026rsquo;s migrations so Laravel knows about them and running them can be done simply by using php arisan migrate. This is done in the Service\u0026rsquo;s service provider class (in our example it\u0026rsquo;s ChatServiceProvider) that we added to our app\u0026rsquo;s providers upon creation.\nGenerate Migration Signature lucid make:migration \u0026lt;migration\u0026gt; \u0026lt;service\u0026gt;\nExample\nlucid make:migration create_messages_table chat Will generate app/Services/Chat/database/migrations/{date}_create_messages_table.php\n\u0026lt;?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; class CreateMessagesTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(\u0026#39;messages\u0026#39;, function (Blueprint $table) { $table-\u0026gt;id(); $table-\u0026gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists(\u0026#39;messages\u0026#39;); } } Run Service Migrations Our migrations are recognized by Laravel due to them being loaded automatically in the service provider - ChatServiceProvider in this example.\nWhich makes it straight-forward to run them:\nphp artisan migrate Removing Migrations In the case where your service doesn\u0026rsquo;t use any of the database functionalities and you\u0026rsquo;d like to tidy up by deleting the database folder, make sure you remove the following from the service provider - typically at app/Services/{name}/Providers/{name}ServiceProvider.php\npublic function boot() { $this-\u0026gt;loadMigrationsFrom([ realpath(__DIR__ . \u0026#39;/../database/migrations\u0026#39;) ]); } Lang \u0026amp; Views Each service is provided with its own resources directory that resembles Laravel\u0026rsquo;s, containing views and lang. All the files that are created there will be registered under a namespace named in snake_case after the service\u0026rsquo;s name.\nThis is initially done in the Service Provider upon creating the service, for example in ChatServiceProvider::registerResources:\nprotected function registerResources() { // Translation must be registered ahead of adding lang namespaces  $this-\u0026gt;app-\u0026gt;register(TranslationServiceProvider::class); Lang::addNamespace(\u0026#39;chat\u0026#39;, realpath(__DIR__.\u0026#39;/../resources/lang\u0026#39;)); View::addNamespace(\u0026#39;chat\u0026#39;, base_path(\u0026#39;resources/views/vendor/chat\u0026#39;)); View::addNamespace(\u0026#39;chat\u0026#39;, realpath(__DIR__.\u0026#39;/../resources/views\u0026#39;)); } To use these views simply prepend them with their corresponding namespace {namespace}::{view}.\nRoute::get(\u0026#39;/chat\u0026#39;, function() { return view(\u0026#39;chat::welcome\u0026#39;); }); For multi-word services such as ProductManagement it will be product_management::welcome.\nIf your service doesn\u0026rsquo;t use views and you\u0026rsquo;d like to de-clutter, feel free to remove the resources folder altogether and remember to remove registerResources method from the service provider as well as its call in register.\nTests Testing services is about testing their features and operations, they\u0026rsquo;re scoped within the services themsevles for better encapsulation app/Services/{service}/Tests/{Features,Operations}.\nInitially service tests aren\u0026rsquo;t automatically registered in phpunit.xml to run by default when running phpunit. To do that, please add the following to your phpunit.xml under \u0026lt;testsuites\u0026gt; (must be done for each service), which also allows running the service\u0026rsquo;s testsuite in isolation with phpunit --testsuite \u0026lt;name\u0026gt;\n\u0026lt;testsuite name=\u0026#34;Chat\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./app/Services/Chat/Tests\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; It is also recommended to namespace your test classes just to avoid conflicts. This is done by default for features and operations that are generated using lucid make:* following PSR-4 standard. An initial test could look like this:\n\u0026lt;?php namespace App\\Services\\Chat\\Tests\\Features; use Tests\\TestCase; use App\\Services\\Chat\\Features\\SendMessageFeature; class SendMessageFeatureTest extends TestCase { public function test_sendmessagefeature() { $this-\u0026gt;markTestIncomplete(); } } Providers Service providers are the connecting wires between the Lucid stack and Laravel especially when it comes to services, they are used to tell Laravel where our code is and what to load, from where, and when.\nEach service comes with its own set of providers in app/Services/{service}/Providers and most essentially the service\u0026rsquo;s own provider that is usually named after the service e.g. ChatServiceProvider or ProductManagementServiceProvider.\nFor Laravel to know about our service and load its files such as database migrations, lang, views and any other classes and elements you would like to register in that service specifically, the service provider must be part of providers in config/app.php\n\u0026#39;providers\u0026#39; =\u0026gt; [ ... App\\Services\\Api\\Providers\\ApiServiceProvider::class, App\\Services\\Chat\\Providers\\ChatServiceProvider::class, App\\Services\\ProductManagement\\Providers\\ProductManagementServiceProvider::class, ] Custom Service Provider We can create and register our own providers which allows us to segregate functionality further within our services:\napp/Services/Chat/Providers/RiakServiceProvider\n\u0026lt;?php namespace App\\Services\\Chat\\Providers; use Riak\\Connection; use Illuminate\\Support\\ServiceProvider; class RiakServiceProvider extends ServiceProvider { /** * Register any application services. * * @return void */ public function register() { $this-\u0026gt;app-\u0026gt;singleton(Connection::class, function ($app) { return new Connection(config(\u0026#39;riak\u0026#39;)); }); } } Then register RiakServiceProvider in the service\u0026rsquo;s provider to be automatically loaded whenever the service\u0026rsquo;s provider is loadeo:\napp/Services/Chat/Providers/ChatServiceProvider\npublic function regsiter() { $this-\u0026gt;app-\u0026gt;register(RiakServiceProvider::class); } A Note On Microservices Talking about projects at scale may often lead us to talk about Microservices. Turning your Monolith services into several instances of their own is one of the ways you may benefit from using services in a Monolith since each resembles a Laravel project, and naturally in microservies we\u0026rsquo;d create a separate Laravel installation for each microservice, our Lucid services are ready for that due to the correspondence in structure; nevertheless it would still require considerable effort to make the move but it is reduced significantly with this in hand, especially that there will be much more to consider in the transformation.\nThis is likely to occur in a number of projects but certainly not all of them.\n In Lucid terms: each of the services will become a Micro instance, preserving features \u0026amp; operations with their entrypoints and their tests. What will be left as a dependency is domains and data which can be created in a package and shared among the microservices that require it. Even though you may wish to also have proprietary domains in the services themselves which will be possible to do as well.\nVisit \u0026ldquo;Micro vs. Monolith\u0026rdquo; for more.\nSOA \u0026amp; Lucid When the word \u0026ldquo;services\u0026rdquo; is mentinoed it is invevitable to drift in thought towards Service-Orienter Architecture, where controllers call a method from a \u0026ldquo;service\u0026rdquo; class that performs the work required. In most cases where this structure is used, it was found that eventually services became the new controllers - large and full of unmaintainable logic. In addition to the difficulty in sharing code between services due to the tight coupling with other components.\nFor that reason, Lucid services take it up a level to give the service a structure that allows it to grow, by organize its code according to a familiar structure and expose its functionalities.\nAre Lucid Services Complient to SOA? In brief, yes. However, there\u0026rsquo;s a difference in the hierarchy:\n In SOA, the application layer is at the top, it includes the services that are needed and the application registers and handles the routing, controller and directs the requests to the service\u0026rsquo;s entrypoint. Lucid Services on the other hand give that power to the service so that it implements all that is required from routes, controllers, and the rest, and the application will only register the service. This approach has proven to be efficient at scale due to the degree of separation, specifically with team collaboration, interoperability and integrity.    "},{"uri":"https://docs.lucidarch.dev/domains/","title":"Domains","tags":[],"description":"","content":"Inspired by Domain-Driven Development, this piece of the Lucid stack is merely directories that are all about organizing and categorizing code according to the topic they belong to.\nThere is no specific way of organizing them because it differs per case, but according to our experience over the years we found that they\u0026rsquo;re usually of two types, the \u0026ldquo;internal\u0026rdquo; and the \u0026ldquo;external\u0026rdquo; type of domain. Here are a few examples to illustrate the difference\nInternal\n Http  RespondWithJsonJob RespondWithJsonErrorJob RespondWithHtmlJob RespondWithHtmlErrorJob RespondWithViewJob   Chat  SendMessageToChannelJob     External\n GitHub  LoginWithGitHubJob FetchGitHubReposJob   Facebook  LoginWithFacebookJob FetchUserPostsJob      Even though they differ in the nature of functionalities they expose, these are still domains from which our application would (re)use code wherever possible. This separation is only logical to help with the understanding of domains but is not an actual separation in code.\nCharacteristics  Isolation: Domains operate in isolation in the sense that they should never need anything from another domain to accomplish their job. They may, however, use elements from the framework or Foundation for abstraction reasons and to eliminate code replication. Encapsulation: Ideally, domains should be structured in a way that would allow them to be moved around with the least amount of impact on their output. They contain their jobs, requests/validation, tests and other custom classes to get their job done.  Consider domain jobs to be the pieces of code that will be shared and reused the most, they can be called from anywhere which makes it essential that they do not depend on any other domain.\nWhat Goes Into A Domain From the Lucid stack, domains contain Job classes and their tests, acting as the only way of communicating with a domain. However any other class that belongs to the domain should also be present there for centralisation.\nConsider the example of an application that integrates with GitHub to login as a GitHub user and it allows to fetch a repository\u0026rsquo;s info from GitHub\u0026rsquo;s API:\n app/Domains/GitHub ‚îú‚îÄ‚îÄ GitHubClient.php ‚îú‚îÄ‚îÄ Jobs ‚îÇ¬†‚îú‚îÄ‚îÄ FetchGitHubRepoInfoJob.php ‚îÇ¬†‚îî‚îÄ‚îÄ LoginWithGitHubJob.php ‚îú‚îÄ‚îÄ Exceptions ‚îÇ¬†‚îú‚îÄ‚îÄ InvalidTokenException.php ‚îÇ¬†‚îî‚îÄ‚îÄ RepositoryNotFoundException.php ‚îî‚îÄ‚îÄ Tests ‚îî‚îÄ‚îÄ GitHubClientTest.php ‚îî‚îÄ‚îÄ Jobs ‚îú‚îÄ‚îÄ FetchGitHubReposJobTest.php ‚îî‚îÄ‚îÄ LoginWithGitHubJobTest.php   GitHubClient is the class that the jobs use to communicate with GitHub\u0026rsquo;s API. FetchGitHubRepoInfoJob contains all the details required to call the API such as URL and query params, exposing them through parameters in the signature, and using the rest of the classes from the domain:  ¬†This code snippet is fictional, it is for demonstrative purposes only and is not meant to work as-is in real life.\n \u0026lt;?php namespace App\\Domains\\GitHub\\Jobs; use Lucid\\Units\\Job; use App\\Domains\\GitHub\\GitHubClient; use App\\Domains\\GitHub\\Exceptions\\InvalidTokenException; use App\\Domains\\GitHub\\Exceptions\\RepositoryNotFoundException; class FetchGitHubRepoInfoJob extends Job { private $name; private $includeCollaborators; public function __construct($name, $includeCollaborators = false) { $this-\u0026gt;name = $name; $this-\u0026gt;includeCollaborators = $includeCollaborators; } public function handle(GitHubClient $github) { $params = []; if ($this-\u0026gt;includeCollaborators) { $params = \u0026#39;with_collaborators\u0026#39;; } $response = $github-\u0026gt;repo($this-\u0026gt;name, $params); switch($response-\u0026gt;status) { case 404: throw new RepositoryNotFoundException(); break; case 403: throw new InvalidTokenException(); break; } return $response; } } Testing Domains contain the tests of their jobs and classes in order to be self-sufficient. They are considered to be unit tests so that the domain can provide the guarantee of a working unit, that way we focus on feature tests in the rest of the application.\nWhen generating Jobs, their tests are automatically generated in the corresponding locations:\nlucid make:job FetchGitHubRepoInfoJob GitHub Will generate two files:\n app/Domains/GitHub/Jobs/FetchGitHubRepoInfoJob.php app/Domains/GitHub/Tests/FetchGitHubRepoInfoJobTest.php  However these tests will not be recognized by PHPUnit, to configure them add the following to phpunit.xml under \u0026lt;testsuites\u0026gt; and the next time you run phpunit all your tests within domains will be included automatically in the run:\n\u0026lt;testsuite name=\u0026#34;Domains\u0026#34;\u0026gt; \u0026lt;directory suffix=\u0026#34;Test.php\u0026#34;\u0026gt;./app/Domains\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; "},{"uri":"https://docs.lucidarch.dev/micro-vs-monolith/","title":"Micro ‚Ä¢ Monolith","tags":[],"description":"","content":"Often times we start projects not knowing how they will evolve over time, they may reach a steady maintainance stage with small tweaks here and there, or undergo pivots that require a high degree of flexibility to not clutter and cause an abundance of technical debt.\nIn both cases, the familiarity with the system\u0026rsquo;s architecture is the guaranteed constant to protect our codebase from going out of bounds.\n Lucid is provided in two variants - Micro and Monolith - to accompany a wide range of projects at all stages and provide the versatility of moving between one and the other, which is attributed to the composability of the Lucid stack, where you could use the units you need with no commitment to others - yet like lego bricks they all fit together when the need for them arises.\nMicro A single-purpose project that contains a moderate amount of functionalities that fit in a similar context.\nIt contains the fundamental units of the Lucid stack: Domains, Features, Operations and Data, complementing the Laravel framework:\n app ‚îú‚îÄ‚îÄ Console ‚îÇ¬†‚îî‚îÄ‚îÄ Kernel.php ‚îú‚îÄ‚îÄ Data ‚îî‚îÄ‚îÄ Models ‚îú‚îÄ‚îÄ Domains ‚îú‚îÄ‚îÄ Features ‚îú‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ Exceptions ‚îÇ¬†‚îî‚îÄ‚îÄ Handler.php ‚îú‚îÄ‚îÄ Http ‚îÇ¬†‚îú‚îÄ‚îÄ Controllers ‚îÇ¬†‚îú‚îÄ‚îÄ Kernel.php ‚îÇ¬†‚îî‚îÄ‚îÄ Middleware ‚îú‚îÄ‚îÄ Policies ‚îî‚îÄ‚îÄ Providers ‚îú‚îÄ‚îÄ AppServiceProvider.php ‚îú‚îÄ‚îÄ AuthServiceProvider.php ‚îú‚îÄ‚îÄ BroadcastServiceProvider.php ‚îú‚îÄ‚îÄ EventServiceProvider.php ‚îî‚îÄ‚îÄ RouteServiceProvider.php  When To Use Micro? Micro is suitable for most projects, including quick prototypes that are ought to become actual products at some point which is where Lucid comes in to reduce the technical debt imposed over time. Or API projects that are meant to be organized for scale.\nAlso as the name suggests they are best suitable for Microservices, where you would have multiple instances of Laravel ‚Ä¢ Lucid Micro, each representing a microservice in your system.\nMonolith A multi-purpose project that exposes functionality in groups that are best separated into their own contexts physically, mirroring their logical separation and encapsulation. To achieve this we use Services - the differentiating factor of Monolith in the Lucid stack.\nHaving services means we\u0026rsquo;re expanding the functionalities that are available at the framework level, into a contextualised division as an extension. Enabling us to replicate the framework structure into sub-structures that contain routes, controllers, views, resources, tests, features and operations of their own, yet all connected together by sharing code using Domains and Data.\nThere are several ways to segregate services, below we mention two of the most common ways: Multifaceted and Multifunctional.\nExample: Multifaceted Project Is a project that has multiple facets like Api, Admin, Web; where each would have their own way of authenticating users, authorizing requests and responding to them in corresponding formats.\n app ‚îú‚îÄ‚îÄ Console ‚îú‚îÄ‚îÄ Data ‚îî‚îÄ‚îÄ Models ‚îú‚îÄ‚îÄ Domains ‚îú‚îÄ‚îÄ Exceptions ‚îú‚îÄ‚îÄ Foundation ‚îú‚îÄ‚îÄ Http ‚îú‚îÄ‚îÄ Policies ‚îú‚îÄ‚îÄ Providers ‚îî‚îÄ‚îÄ Services ‚îú‚îÄ‚îÄ Admin ‚îú‚îÄ‚îÄ Api ‚îî‚îÄ‚îÄ Web ‚îú‚îÄ‚îÄ artisan ‚îú‚îÄ‚îÄ bootstrap ‚îú‚îÄ‚îÄ composer.json ‚îú‚îÄ‚îÄ composer.lock ‚îú‚îÄ‚îÄ config ‚îú‚îÄ‚îÄ database ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ phpunit.xml ‚îú‚îÄ‚îÄ public ‚îú‚îÄ‚îÄ resources ‚îú‚îÄ‚îÄ routes ‚îú‚îÄ‚îÄ server.php ‚îú‚îÄ‚îÄ storage ‚îú‚îÄ‚îÄ tests ‚îî‚îÄ‚îÄ webpack.mix.js    app/Services/{Admin,Api,Web} ‚îú‚îÄ‚îÄ Console ‚îÇ¬†‚îî‚îÄ‚îÄ Commands ‚îú‚îÄ‚îÄ Features ‚îú‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ Http ‚îÇ¬†‚îú‚îÄ‚îÄ Controllers ‚îÇ¬†‚îî‚îÄ‚îÄ Middleware ‚îú‚îÄ‚îÄ Providers ‚îÇ¬†‚îú‚îÄ‚îÄ {Admin,Api,Web}ServiceProvider.php ‚îÇ¬†‚îú‚îÄ‚îÄ BroadcastServiceProvider.php ‚îÇ¬†‚îî‚îÄ‚îÄ RouteServiceProvider.php ‚îú‚îÄ‚îÄ Tests ‚îÇ¬†‚îú‚îÄ‚îÄ Features ‚îÇ¬†‚îî‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ database ‚îÇ¬†‚îú‚îÄ‚îÄ factories ‚îÇ¬†‚îú‚îÄ‚îÄ migrations ‚îÇ¬†‚îî‚îÄ‚îÄ seeds ‚îú‚îÄ‚îÄ resources ‚îÇ¬†‚îú‚îÄ‚îÄ lang ‚îÇ¬†‚îî‚îÄ‚îÄ views ‚îî‚îÄ‚îÄ routes ‚îú‚îÄ‚îÄ api.php ‚îú‚îÄ‚îÄ channels.php ‚îú‚îÄ‚îÄ console.php ‚îî‚îÄ‚îÄ web.php    Example: Multifunction project Is a project with a wide range of functions that are best separated in logic due to the degree of difference in the areas they serve, like an application that has Chat, Product Management, Ecommerce (web UI) and an API.\nThe structure and usage is the same as multifacet, they only differ in concept and their logical separation. As illustrated below, the naming of the services is different between the projects yet their internals are exactly the same. What matters is to choose whichever approach works best for your case and maintain it consistently.\n app ‚îú‚îÄ‚îÄ Console ‚îú‚îÄ‚îÄ Data ‚îî‚îÄ‚îÄ Models ‚îú‚îÄ‚îÄ Domains ‚îú‚îÄ‚îÄ Exceptions ‚îú‚îÄ‚îÄ Foundation ‚îú‚îÄ‚îÄ Http ‚îú‚îÄ‚îÄ Policies ‚îú‚îÄ‚îÄ Providers ‚îî‚îÄ‚îÄ Services ‚îú‚îÄ‚îÄ Chat ‚îú‚îÄ‚îÄ Ecommerce ‚îú‚îÄ‚îÄ ProductManagement ‚îî‚îÄ‚îÄ Api ‚îú‚îÄ‚îÄ artisan ‚îú‚îÄ‚îÄ bootstrap ‚îú‚îÄ‚îÄ composer.json ‚îú‚îÄ‚îÄ composer.lock ‚îú‚îÄ‚îÄ config ‚îú‚îÄ‚îÄ database ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ phpunit.xml ‚îú‚îÄ‚îÄ public ‚îú‚îÄ‚îÄ resources ‚îú‚îÄ‚îÄ routes ‚îú‚îÄ‚îÄ server.php ‚îú‚îÄ‚îÄ storage ‚îú‚îÄ‚îÄ tests ‚îî‚îÄ‚îÄ webpack.mix.js    app/Services/{Chat,Api,Ecommerce,ProductManagement} ‚îú‚îÄ‚îÄ Console ‚îÇ¬†‚îî‚îÄ‚îÄ Commands ‚îú‚îÄ‚îÄ Features ‚îú‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ Http ‚îÇ¬†‚îú‚îÄ‚îÄ Controllers ‚îÇ¬†‚îî‚îÄ‚îÄ Middleware ‚îú‚îÄ‚îÄ Providers ‚îÇ¬†‚îú‚îÄ‚îÄ {Chat,Api,Ecommerce,ProductManagement}ServiceProvider.php ‚îÇ¬†‚îú‚îÄ‚îÄ BroadcastServiceProvider.php ‚îÇ¬†‚îî‚îÄ‚îÄ RouteServiceProvider.php ‚îú‚îÄ‚îÄ Tests ‚îÇ¬†‚îú‚îÄ‚îÄ Features ‚îÇ¬†‚îî‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ database ‚îÇ¬†‚îú‚îÄ‚îÄ factories ‚îÇ¬†‚îú‚îÄ‚îÄ migrations ‚îÇ¬†‚îî‚îÄ‚îÄ seeds ‚îú‚îÄ‚îÄ resources ‚îÇ¬†‚îú‚îÄ‚îÄ lang ‚îÇ¬†‚îî‚îÄ‚îÄ views ‚îî‚îÄ‚îÄ routes ‚îú‚îÄ‚îÄ api.php ‚îú‚îÄ‚îÄ channels.php ‚îú‚îÄ‚îÄ console.php ‚îî‚îÄ‚îÄ web.php    ¬†These are only two approaches to services, but there certainly are other creative ways you could benefit from them. Go crazy!\n When To Use Monolith? Monolith is suitable for projects that have been pre-defined with a large set of functionalities across multiple sections and are known to grow vertically in functionality as well as horizontally in more areas. However this is not always easy to guess from the start, especially when having to identify the services involved, which is why it will be easy to start with Micro and then move to Monolith when the project has gotten better definition.\nAlso, Monolith projects have been witnessed to grow beyond the initially anticipated scale, to then be split into Microservices themselves, and Lucid happens to be perfect for the case where each of the Services is moved to its own Micro instance.\n"},{"uri":"https://docs.lucidarch.dev/validation/","title":"Validation","tags":[],"description":"","content":"As common as it is, validation is essential for every application. Lucid brings a domain-driven approach that embraces Laravel\u0026rsquo;s validation. In short, if you\u0026rsquo;ve done validation with Laravel you\u0026rsquo;re already familiar with everything here, we will only choose convenient locations for Validators and Form Requests by placing them in domains.\nDomain-Driven Validation Often times validation is a matter of context, and domains in Lucid are an ideal place to encapsulate functionality, and form requests fit perfectly there! e.g. Domains/{domain}/Requests/{Request}.php\nEventually we\u0026rsquo;d end up with a categorical directory structure that protects our validation files from becoming unmanageable.\nForm Requests\napp/Domains ‚îú‚îÄ‚îÄ Chat ‚îÇ¬†‚îî‚îÄ‚îÄ Requests ‚îÇ¬†‚îî‚îÄ‚îÄ SendMessage.php ‚îú‚îÄ‚îÄ Comment ‚îÇ¬†‚îî‚îÄ‚îÄ Requests ‚îÇ¬†‚îî‚îÄ‚îÄ AddComment.php ‚îú‚îÄ‚îÄ Filesystem ‚îÇ¬†‚îî‚îÄ‚îÄ Requests ‚îÇ¬†‚îî‚îÄ‚îÄ UploadFiles.php ‚îî‚îÄ‚îÄ Post ‚îî‚îÄ‚îÄ Requests ‚îú‚îÄ‚îÄ CreatePost.php ‚îî‚îÄ‚îÄ UpdatePost.php   Validation Jobs\napp/Domains ‚îú‚îÄ‚îÄ Chat ‚îÇ¬†‚îî‚îÄ‚îÄ Jobs ‚îÇ¬†‚îî‚îÄ‚îÄ ValidateNewMessageJob.php ‚îú‚îÄ‚îÄ Comment ‚îÇ¬†‚îî‚îÄ‚îÄ Jobs ‚îÇ¬†‚îî‚îÄ‚îÄ ValidateNewCommentJob.php ‚îú‚îÄ‚îÄ Filesystem ‚îÇ¬†‚îî‚îÄ‚îÄ Jobs ‚îÇ¬†‚îî‚îÄ‚îÄ ValidateFilesUploadJob.php ‚îî‚îÄ‚îÄ Post ‚îî‚îÄ‚îÄ Jobs ‚îú‚îÄ‚îÄ ValidateNewPostJob.php ‚îî‚îÄ‚îÄ ValidatePostUpdateJob.php    Form Request Validation In an effort to keep our controllers thin and reduce their clutter, as well as having features carry their requirements with them wherever we decide to serve them from, it is recommended for validation using Form Request to happen in features instead of controllers, to maintain their integrity whenever they\u0026rsquo;re served.\nNevertheless, it is done exactly the same as Laravel controllers in any of Lucid\u0026rsquo;s units, by injecting the form request class in the method signature as a parameter:\nclass CustomFeature extends Feature { public function handle(UpdatePost $request) { // request is valid according to the rules specified in UpdatePost  } } This will perform Form Request Validation using UpdatePost class.\n¬†The same can be done in any unit: Feature, Job and Operation.\n For more on Form Request classes see Laravel\u0026rsquo;s docs.\n Generate Form Request Micro Signature\nlucid make:request \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt; Example\nlucid make:request UpdatePost post Generated class will be at app/Domains/Post/Requests/UpdatePost.php\nMonolith Signature\nlucid make:request \u0026lt;name\u0026gt; \u0026lt;domain\u0026gt; Example\nlucid make:request UpdatePost post Generated class will be at src/Domains/Post/Requests/UpdatePost.php\n \n\u0026lt;?php namespace App\\Domains\\Post\\Requests; use Illuminate\\Foundation\\Http\\FormRequest; class UpdatePost extends FormRequest { /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * * @return array */ public function rules() { return [ //  ]; } } Requests as Unit Dispatchers One of the most powerful aspects of Lucid is the degree of code reuse it introduces. Specifically when dealing with Job and Operation classes which can be called from any custom dispatcher class.\nHere, we will be setting up UpdatePost Request class to authorize using AuthorizeUserOperation, and on after hook to run FaliedValidationJob.\nBenefit: Doing so would increase the degree of consistency and integrity in our application, where AuthorizeUserOperation could contain our consolidated authorization mechanism and can be called from any other class such as middleware to authoriza pre-flight. As for FaliedValidationJob it will ensure that all of our failed validations are handled consistently as expected.\n \u0026lt;?php namespace App\\Domains\\Post\\Requests; use Lucid\\Bus\\UnitDispatcher; use App\\Operations\\AuthorizeUserOperation; use Illuminate\\Foundation\\Http\\FormRequest; use App\\Domains\\Http\\Jobs\\FailedValidationJob; class UpdatePost extends FormRequest { use UnitDispatcher; public function authorize() { return $this-\u0026gt;run(AuthorizeUserOperation::class); } public function rules() { return [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|unique:posts|max:255\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required\u0026#39;, ]; } public function withValidator($validator) { $validator-\u0026gt;after(function ($validator) { if ($this-\u0026gt;somethingElseIsInvalid()) { $this-\u0026gt;run(new FailedValidationJob($validator)); } }); } } Validation Jobs Another approach to validation is to validate using jobs. This is most useful with protocols other than HTTP (e.g. Console, AMQP, etc.), or if you simply choose not to use Requests.\nOur validation jobs would contain validation logic so it can be called whenever validation is required.\nStart by creating a job:\nlucid make:job ValidatePostUpdate post Then inject Illuminate\\Http\\Request and fill in your validation logic:\n\u0026lt;?php namespace App\\Domains\\Post\\Jobs; use Lucid\\Units\\Job; use Illuminate\\Http\\Request; class ValidatePostUpdateJob extends Job { public function handle(Request $request) { $validData = $request-\u0026gt;validate([ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|unique:posts|max:255\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required\u0026#39;, ]); return $validData; } } "},{"uri":"https://docs.lucidarch.dev/cli/","title":"CLI Reference","tags":[],"description":"","content":"The lucid command line interface companion for the Lucid Architecture.\nlucid is a set of methods to easily manage [create, delete] Lucid units such as Jobs, Operations, Features as well as Laravel\u0026rsquo;s own components such as Controller, Eloquent Model, Request and Policy; ensuring that they go where they belong and are generated with their test companion classes.\n Setup The executable binary can be found at ./vendor/bin/lucid after requiring lucid-arch/console.\nFor convenience you might want to address lucid directly instead of having to go through ./vendor/bin every time. To do that you need to add ./vendor/bin to your shell session\u0026rsquo;s $PATH. For the current session, run:\nexport PATH=\u0026#34;./vendor/bin:$PATH\u0026#34; However, it will only be available for the current session. To make it permanent, add it to your shell profile (~/.bash_profile, ~/.bashrc, ~/.zshrc) and you will be able to simply call lucid from the application\u0026rsquo;s root directory.\nUse list to view a list of all available commands:\nlucid list Also, just like in Artisan, every command includes a \u0026ldquo;help\u0026rdquo; screen describes the command\u0026rsquo;s available arguments and options. To view a help screen, precede the name of the command with help or use the --help option:\nlucid help make:feature # or lucid make:feature --help Commands src:name Set the root namespace.\nlucid src:name \u0026lt;namespace\u0026gt;  make:service ¬†For Monolith projects only.\n Create a new service in a monolith project.\nlucid make:service \u0026lt;name\u0026gt; # example lucid make:service HumanResources Will generate the following structure:\nsrc ‚îî‚îÄ‚îÄ Services ‚îî‚îÄ‚îÄ HumanResources ‚îú‚îÄ‚îÄ Providers ‚îú‚îÄ‚îÄ Console ‚îú‚îÄ‚îÄ Http ‚îú‚îÄ‚îÄ Features ‚îú‚îÄ‚îÄ Operations ‚îú‚îÄ‚îÄ Tests ‚îú‚îÄ‚îÄ database ‚îú‚îÄ‚îÄ routes ‚îî‚îÄ‚îÄ resources  make:controller Generate a controller class.\nMicro Signature\nlucid make:controller \u0026lt;controller\u0026gt; Example\nlucid make:controller Article Generated class will be at app/Http/Controllers/ArticleController.php\nMonolith Signature\nlucid make:controller \u0026lt;controller\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:controller Article Publishing Generated class will be at src/Services/Publishing/Http/Controllers/ArticleController.php\n Empty Controller\nBy default it will generate an empty controller. To generate a resource controller use the --resource option:\nlucid make:controller \u0026lt;controller\u0026gt; [\u0026lt;service\u0026gt;] --resource  make:feature Generate a Feature class.\nMicro Signature\nlucid make:feature \u0026lt;feature\u0026gt; Example\nlucid make:feature ListProducts Generated class will be at app/Features/ListProductsFeatures.php\nand its test at tests/Features/ListProductsFeaturesTest.php\nMonolith Signature\nlucid make:feature \u0026lt;feature\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:feature ListProducts Commerce Generated class will be at src/Services/Commerce/Features/ListProductsFeatures.php\nand its test at src/Services/Commerce/Tests/Features/ListProductsFeaturesTest.php\n The generated Feature class will automatically be suffixed with Feature, so there\u0026rsquo;s no need for it to be specified in the command.\n make:job Generate a Job class.\nMicro Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at app/Domains/Product/Jobs/FindProductJob.php\nand its test at tests/Domains/Product/Tests/FindProductJobTest.php\nMonolith Signature\nlucid make:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; {--Q|queue} Example\nlucid make:job FindProduct product Generated class will be at src/Domains/Product/Jobs/FindProductJob.php\nand its test at src/Domains/Product/Tests/FindProductJobTest.php\n The generated Job class will automatically be suffixed with Job, so there\u0026rsquo;s no need for it to be specified in the command.\n make:operation Micro Signature\nlucid make:operation \u0026lt;operation\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers Generated class will be at app/Operations/NotifySubscribersOperation.php\nand its test at tests/Operations/NotifySubscribersOperationTest.php\nMonolith Signature\nlucid make:operation \u0026lt;operation\u0026gt; \u0026lt;service\u0026gt; {--Q|queue} Example\nlucid make:operation NotifySubscribers publishing Generated class will be at src/Services/Publishing/Operations/NotifySubscribersOperation.php\nand its test at src/Services/Publishing/Tests/Operations/NotifySubscribersOperationTest.php\n The generated Operation class will automatically be suffixed with Operation, so there\u0026rsquo;s no need for it to be specified in the command.\n make:migration Micro Signature\nlucid make:migration \u0026lt;migration\u0026gt; Example\nlucid make:migration create_articles_table Generated file will be at database/migrations/2020_10_28_180253_create_articles_table.php\nMonolith Signature\nlucid make:migration \u0026lt;migration\u0026gt; \u0026lt;service\u0026gt; Example\nlucid make:migration create_articles_table publishing Generated file will be at src/Services/Publishing/database/migrations/2020_10_28_180253_create_articles_table.php\n  make:model Generate an Eloquent model class.\nSignature\nlucid make:model \u0026lt;name\u0026gt; Example\nlucid make:model Product Generated model file will be at [app|src]/Data/Product.php.\n make:request Micro lucid make:request \u0026lt;request\u0026gt; \u0026lt;domain\u0026gt; Generated file will be at app/Domains/\u0026lt;domain\u0026gt;/Requests/\u0026lt;request\u0026gt;.\nMonolith lucid make:request \u0026lt;request\u0026gt; \u0026lt;domain\u0026gt; Generated file will be at src/Domains/\u0026lt;domain\u0026gt;/Requests/\u0026lt;request\u0026gt;.\n  make:policy Micro lucid make:policy \u0026lt;policy\u0026gt; Generated file will be at app/Http/Policies/\u0026lt;policy\u0026gt;.\nMonolith lucid make:policy \u0026lt;policy\u0026gt; \u0026lt;service\u0026gt; Generated file will be at src/Services/\u0026lt;service\u0026gt;/Http/Policies/\u0026lt;policy\u0026gt;.\n  list:services List the services in a monolith project\n¬†For Monolith projects only.\n lucid list:services +------------+------------+-------------------------+ | Service | Slug | Path | +------------+------------+-------------------------+ | Commerce | commerce | src/Services/Commerce | | Publishing | publishing | src/Services/Publishing | | Admin | admin | src/Services/Admin | +------------+------------+-------------------------+  list:features lucid list:features   delete:service ¬†For Monolith projects only.\n lucid delete service \u0026lt;name\u0026gt; delete:feature lucid delete:feature \u0026lt;feature\u0026gt; [\u0026lt;service\u0026gt;] delete:job lucid delete:job \u0026lt;job\u0026gt; \u0026lt;domain\u0026gt; delete:model delete:model \u0026lt;model\u0026gt; delete:request lucid delete:request \u0026lt;request\u0026gt; [\u0026lt;service\u0026gt;] delete:policy delete:policy \u0026lt;policy\u0026gt; [\u0026lt;service\u0026gt;] "},{"uri":"https://docs.lucidarch.dev/","title":"","tags":[],"description":"","content":""}]